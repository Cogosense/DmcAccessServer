#!/bin/bash
#
# Copyright Dali Wireless 2021
#
# Based on the work:
#
# https://github.com/Nyr/openvpn-install
#
# Copyright (c) 2013 Nyr. Released under the MIT License.

VPNNET=10.8.0.0/24
CFGDIR=/etc/openvpn
CCDDIR=${CFGDIR}/ccd
CLIENTDIR=${CFGDIR}/client
SERVERDIR=${CFGDIR}/server
TOOLDIR=$(cd $(dirname $0) && pwd)
STATEDIR=$TOOLDIR/state
GWYSTATEDIR=$STATEDIR/gateways
SVRSTATEDIR=$STATEDIR/server
: ${NETPLANDIR:=/etc/netplan}
progname=$(basename $0)

opt_s=''
opt_r=''

usage() {
    cat << _EOF

"$progname" manage the DMC VPN server and remote gateways

Usage: sudo $0 [OPTIONS]
       $0 -h

When run without options $progname runs in an interactive mode. The use
of "sudo" is required for all actions except the help screen.

The first time it is run, the OVPN server, SNMP server, SSH server and the
network topology will be initialized and a first gateway config created.

Subsequent runs with no options can be used to add gateways and to revoke
gateways.

The following options can be used to mirror the configuration to a cold standby
DMC access server. The active server should be saved after any changes to the
remote gateway configuration, then restored on the standby side.

NOTE: On the standby side, a saved configuration should be restored  after
$progname has been run once. This will overwrite the initial gateway created in
the setup process on the standby side, and will render the standby a clone of the
active DMC access server. The initial setup is required to ensure the necessary
software packages are installed.

OPTIONS:

 -h               This help screen (does not require sudo)
 -s  [IP|TARFILE] Save server config directly to IP address, or save to TARFILE
                  for manual transfer to standby system.
 -r  [TARFILE]    Restore DMC access server config from the TARFILE.
 -x               Turn on bash shell tracing.

_EOF
}

[ -d $STATEDIR ] || mkdir $STATEDIR
[ -f $STATEDIR/.snmpauth ] && . $STATEDIR/.snmpauth

# Detect Debian users running the script with "sh" instead of bash
if readlink /proc/$$/exe | grep -q "dash"; then
    echo 'This installer needs to be run with "bash", not "sh".'
    exit
fi

# Discard stdin. Needed when running from an one-liner which includes a newline
read -N 999999 -t 0.001

# Detect OpenVZ 6
if [[ $(uname -r | cut -d "." -f 1) -eq 2 ]]; then
    echo "The system is running an old kernel, which is incompatible with this installer."
    exit
fi

# Detect OS
# $os_version variables aren't always in use, but are kept here for convenience
if grep -qs "ubuntu" /etc/os-release; then
    os="ubuntu"
    os_version=$(grep 'VERSION_ID' /etc/os-release | cut -d '"' -f 2 | tr -d '.')
    group_name="nogroup"
elif [[ -e /etc/debian_version ]]; then
    os="debian"
    os_version=$(grep -oE '[0-9]+' /etc/debian_version | head -1)
    group_name="nogroup"
elif [[ -e /etc/centos-release ]]; then
    os="centos"
    os_version=$(grep -oE '[0-9]+' /etc/centos-release | head -1)
    group_name="nobody"
elif [[ -e /etc/fedora-release ]]; then
    os="fedora"
    os_version=$(grep -oE '[0-9]+' /etc/fedora-release | head -1)
    group_name="nobody"
else
    echo "This installer seems to be running on an unsupported distribution.
Supported distributions are Ubuntu, Debian, CentOS, and Fedora."
    exit
fi

if [[ "$os" == "ubuntu" && "$os_version" -lt 1804 ]]; then
    echo "Ubuntu 18.04 or higher is required to use this installer.
This version of Ubuntu is too old and unsupported."
    exit
fi

if [[ "$os" == "debian" && "$os_version" -lt 9 ]]; then
    echo "Debian 9 or higher is required to use this installer.
This version of Debian is too old and unsupported."
    exit
fi

if [[ "$os" == "centos" && "$os_version" -lt 7 ]]; then
    echo "CentOS 7 or higher is required to use this installer.
This version of CentOS is too old and unsupported."
    exit
fi

# Detect environments where $PATH does not include the sbin directories
if ! grep -q sbin <<< "$PATH"; then
    echo '$PATH does not include sbin. Try using "su -" instead of "su".'
    exit
fi

if [[ ! -e /dev/net/tun ]] || ! ( exec 7<>/dev/net/tun ) 2>/dev/null; then
    echo "The system does not have the TUN device available.
TUN needs to be enabled before running this installer."
    exit
fi

isroot() {
    if [[ "$EUID" -ne 0 ]]; then
        echo "This installer needs to be run with superuser privileges."
        exit
    fi
}

ip2dec() {
    declare -i a b c d
    IFS=. read a b c d <<<"$1"
    echo "$(((10#$a<<24)+(10#$b<<16)+(10#$c<<8)+10#$d))"
}

dec2ip() {
    local ip=$1
    local i s
    for i in {1..4}; do
        s='.'$((ip%256))$s && ((ip>>=8))
    done
    echo ${s:1}
}

detect_qotom() {
    interfaces=$(ip link | awk '/^[0-9]*: /{print substr($2, 1, length($2)-1)}')
    ifcnt=0
    for interface in $interfaces ; do
        case $interface in
            enp?s0)   ((ifcnt++)) ;;
        esac
    done
    motherboard=$(dmidecode -s baseboard-product-name)
    [ $ifcnt -eq 4 -a "$motherboard" == 'Aptio CRB' ]
    return $?
}

select_wan_interface()
{
    interfaces=($(ip link show | awk '/^[0-9]*: en/{print substr($2, 1, length($2)-1)}'))
    while : ; do
        wanif=$(ip route show default | awk '{print $5}')
        local cnt=1
        for intf in "${interfaces[@]}"; do
            echo "$cnt) $intf"
            let cnt++
        done
        read -p "Which interface is connected to the Internet [$wanif]: " reply
        case $reply in
            "") ;;
            *) wanif="${interfaces[((reply-1))]}" ;;
        esac
        if [ -n "$wanif" ] ; then
            break
        fi
    done
}

select_dmc_interfaces()
{
    echo "Which interface(s) are connected to the DMC?"
    interfaces=($(ip link show | awk '/^[0-9]*: en/{print substr($2, 1, length($2)-1)}' | grep -v lo | grep -v "$wanif"))
    local selected_interfaces=""
    while : ; do
        local cnt=1
        for intf in "${interfaces[@]}"; do
            if grep -q $intf <<< $selected_interfaces ; then
                echo "$cnt) * $intf"
            else
                echo "$cnt)   $intf"
            fi
            let cnt++
        done
        echo "$cnt)   Done"
        read -p "Select interfaces toward DMC? [${selected_interfaces:-none selected}]: " reply
        case $reply in
            $cnt) break 2 ;;
            *) 
                interface="${interfaces[((reply-1))]}"
                if grep -q $interface <<< $selected_interfaces ; then
                    selected_interfaces=$(sed "s/$interface//" <<< $selected_interfaces)
                else
                    selected_interfaces="$selected_interfaces $interface"
                fi
                set -- $selected_interfaces
                selected_interfaces="$*"
                ;;
        esac
    done

    if [ -z "$selected_interfaces" ] ; then
        echo "no DMC interface selected"
        exit
    fi
    dmc_interfaces="$selected_interfaces"
}

create_wan_if() {
    local wanif=$1
    shift
    if [ -f ${NETPLANDIR}/01-network-manager-all.yaml ] ; then
        rm ${NETPLANDIR}/01-network-manager-all.yaml
    fi
    cat < ${TOOLDIR}/templates/server/netplan/00-wan-config.tmpl | wanif="$wanif" envsubst > ${NETPLANDIR}/00-wan-config.yaml
    echo "Activating WAN Interface before proceeding with configuration"
    netplan generate
    netplan apply
    while [ -z "$(ip -4 addr show enp1s0 | awk '/inet/{print $2}')" ] ; do : ; done
}

create_dmc_lanbr() {
    local interfaces="$@"
    local ethernets
    for interface in $interfaces ; do
        ethernets="$ethernets $(interface=$interface envsubst < ${TOOLDIR}/templates/server/netplan/dmc_ethernet.tmpl)"
    done
    interfaces=$(sed 's/[ ][ ]*/,/g' <<< $interfaces)
    cat < ${TOOLDIR}/templates/server/netplan/30-bridge-config.tmpl | ethernets="$ethernets" interfaces="$interfaces" envsubst > ${NETPLANDIR}/30-bridge-config.yaml
    netplan generate
    netplan apply
}

add_tunnel_to_lanbr() {
    local tunnel=$1
    shift
    if ! grep -q "interfaces:[ ]*\[.*${tunnel}.*]"  ${NETPLANDIR}/30-bridge-config.yaml ; then
        cat ${NETPLANDIR}/30-bridge-config.yaml | yq e ".network.bridges.lanbr0.interfaces += \"${tunnel}\"" - > $$.yaml
        mv $$.yaml ${NETPLANDIR}/30-bridge-config.yaml
    fi
}

del_tunnel_from_lanbr() {
    local tunnel=$1
    shift
    if grep -q "interfaces:[ ]*\[.*${tunnel}.*]"  ${NETPLANDIR}/30-bridge-config.yaml ; then
        # yq hasn't implemented '-=' support yet
        interfaces=$(cat ${NETPLANDIR}/30-bridge-config.yaml | yq e ".network.bridges.lanbr0.interfaces" - | sed -r "s/ ?\b${tunnel}\b,?//;s/,,/,/;s/\[ /\[/;s/,]/]/")
        sed -i.bak "s/interfaces:.*$/interfaces: ${interfaces}/" ${NETPLANDIR}/30-bridge-config.yaml
        rm ${NETPLANDIR}/30-bridge-config.yaml.bak
    fi
}

get_current_lanbr_slaves() {
    ip link show master lanbr0 | awk '/^[0-9]*: (en|gre)/{print substr($2, 1, length($2)-1)}' | sed 's/@NONE//'
}

get_next_gretap_device() {
    slaves=`get_current_lanbr_slaves`
    # start gretap devices at 1 (0 can't be used)
    cnt=1
    for (( ; ; cnt++ ))
    do
        tunnel=gretap${cnt}
        if grep -q $tunnel <<< $slaves ; then
            continue
        fi
        echo $tunnel
        break
    done
}

create_tunnel() {
    local name=$1
    shift
    local clientip=$1
    shift
    local serverip=$1
    shift

    if [ ! -f ${NETPLANDIR}/20-tunnel-${name}.yaml ] ; then
        local tunnel=`get_next_gretap_device`
        cat < ${TOOLDIR}/templates/server/netplan/20-tunnel-remotegw-n.tmpl | tunnel="$tunnel" clientip="$clientip" serverip="$serverip" envsubst > ${NETPLANDIR}/20-tunnel-${name}.yaml
        add_tunnel_to_lanbr $tunnel
        netplan generate
        netplan apply
    fi
}

destroy_tunnel() {
    local name=$1
    shift
    if [ -f ${NETPLANDIR}/20-tunnel-${name}.yaml ] ; then
        tunnel=$(cat ${NETPLANDIR}/20-tunnel-${name}.yaml | yq e ".network.tunnels" - | head -1 | sed 's/:$//')
        del_tunnel_from_lanbr $tunnel
        rm ${NETPLANDIR}/20-tunnel-${name}.yaml
        netplan generate
        netplan apply
    fi
}

restore_networking_default() {
    rm ${NETPLANDIR}/*.yaml
    cat < ${TOOLDIR}/templates/server/netplan/01-network-manager-all.tmpl > ${NETPLANDIR}/01-network-manager-all.yaml
    netplan generate
    netplan apply
}

get_server_ip() {
    echo $(ipcalc -nb ${VPNNET} | awk '/HostMin:/{print $2}')
}

get_client_ip() {
    addr_pool=()
    reserved_ips=()
    minhost=$(ipcalc -nb ${VPNNET} | awk '/HostMin:/{print $2}')
    maxhost=$(ipcalc -nb ${VPNNET} | awk '/HostMax:/{print $2}')
    lower=$(ip2dec $minhost)
    upper=$(ip2dec $maxhost)

    for ((i=lower;i<=upper;i++)); do
        addr_pool+=($i)
    done

    reserved_ips+=($lower)

    for client in ${CCDDIR}/* ; do
        if [ -e $client ] ; then
            clientip=$(awk '/^ifconfig-push/{print $2}' $client)
            reserved_ips+=($(ip2dec $clientip))
        fi
    done

    for ip in ${addr_pool[@]}; do
        for reserved in ${reserved_ips[@]}; do
            if [[ $ip -eq $reserved ]] ; then
                continue 2
            fi
        done
        dec2ip $ip
        break
    done
}

save_server_config() {
    local dest=$1
    shift
    case "$dest" in
        *.tar|*.tar.gz|*.tar.bz2|*.tar.xz) tarfile="$dest" ;;
        *)
            if nc -zw 5 "$dest" 22 ; then
                tarfile="state-$(date --iso-8601=minutes).tar.gz"
                host="$dest"
            else
                tarfile="$dest.tar.gz"
            fi
            ;;
    esac
    rm -rf $SVRSTATEDIR
    mkdir -p $SVRSTATEDIR
    cp -a $CFGDIR $SVRSTATEDIR
    cp -a $NETPLANDIR $SVRSTATEDIR
    tar cp -C $TOOLDIR -zf "$tarfile" state
    if [ -n "$host" ] ; then
        echo "Please enter the password for \"dali\" on the standby host"
        scp $tarfile dali@$host:
        echo "state archive $tarfile created and copied to the standby host dali@$host"
    else
        echo "state archive $tarfile created, please copy it to the standby host"
    fi
    echo
    echo "use the following command to import it to the standby host: "
    echo
    echo "        sudo ./dmc-access-mgr -r $tarfile"
}

restore_server_config() {
    local tarfile=$1
    shift
    rm -rf $SVRSTATEDIR
    mkdir -p $SVRSTATEDIR
    if [ -f "$tarfile" ] ; then
        tar xp -C $TOOLDIR -f $tarfile
        rm -rf $CFGDIR.bak
        rm -rf $NETPLANDIR.bak
        mv $CFGDIR $CFGDIR.bak
        mv NETPLANDIR NETPLANDIR.bak
        cp -a $SVRSTATEDIR/openvpn $CFGDIR
        cp -a $SVRSTATEDIR/netplan $NETPLANDIR
        if [ -d $CFGDIR -a -d $NETPLANDIR ] ; then
            netplan generate
            netplan apply
        fi
    fi
}

setup_server_snmpd () {
    local user="$1"
    local password="$2"
    shift 2

    apt install -y openssh-server snmpd snmp libsnmp-dev
    systemctl stop snmpd
    sed -i.bak 's/^sysLocation.*$/sysLocation Dali Management VPN Concentrator/;s/^sysContact.*$/sysContact Dali <support@daliwireless.com>/;s/^agentaddress.*$/agentaddress udp:161,udp6:[::1]:161/' /etc/snmp/snmpd.conf
    net-snmp-create-v3-user -ro -A "$password" -a MD5 -X "$password" -x DES "$user"
    systemctl start snmpd
}

new_client () {
    local serverip=$(get_server_ip)
    local clientip=$(get_client_ip)
    local netmask=$(ipcalc -nb ${VPNNET} | awk '/Netmask:/{print $2}')

    create_tunnel $client $clientip $serverip
    mkdir -p ${GWYSTATEDIR}/$client/etc
    # Generate netplan config for gateway
    mkdir ${GWYSTATEDIR}/$client/etc/netplan
    for template in ${TOOLDIR}/templates/client/netplan/*.tmpl ; do
        if [ -e $template ] ; then
            config=$(basename -s .tmpl $template).yaml
            (
                export CLIENTIP=$clientip
                export SERVERIP=$serverip
                cat $template | envsubst
            ) > ${GWYSTATEDIR}/$client/etc/netplan/$config
        fi
    done

    # Generates the custom client.ovpn
    {
    cat ${SERVERDIR}/client-common.txt
    echo "<ca>"
    cat ${SERVERDIR}/easy-rsa/pki/ca.crt
    echo "</ca>"
    echo "<cert>"
    sed -ne '/BEGIN CERTIFICATE/,$ p' ${SERVERDIR}/easy-rsa/pki/issued/"$client".crt
    echo "</cert>"
    echo "<key>"
    cat ${SERVERDIR}/easy-rsa/pki/private/"$client".key
    echo "</key>"
    echo "<tls-crypt>"
    sed -ne '/BEGIN OpenVPN Static key/,$ p' ${SERVERDIR}/tc.key
    echo "</tls-crypt>"
    } > ${CLIENTDIR}/"$client".ovpn
    echo "ifconfig-push ${clientip} ${netmask}" > ${CCDDIR}/"$client"

    mkdir ${GWYSTATEDIR}/$client/etc/openvpn
    cp ${CLIENTDIR}/"$client".ovpn ${GWYSTATEDIR}/$client/etc/openvpn/"$client".conf
    (
        echo '#!/bin/bash'
        echo "SNMP_USER=\"$snmp_user\""
        echo "SNMP_PASSWORD=\"$snmp_password\""
        cat ${TOOLDIR}/templates/client/selfextract_header
        tar cz -C ${GWYSTATEDIR}/$client .
    ) > ${GWYSTATEDIR}/install_$client.shar

    if [ -n "$SUDO_UID" ] ; then
        chown $SUDO_UID:$SUDO_GID ${GWYSTATEDIR}/$client
        chown $SUDO_UID:$SUDO_GID ${GWYSTATEDIR}/install_$client.shar
    fi
    chmod a+x ${GWYSTATEDIR}/install_${client}.shar

    echo "The install script for the remote gateway \"${client}\" is at:"
    echo ""
    echo "  ${GWYSTATEDIR}/install_${client}.shar"
    echo ""
    echo "Copy this file to the gateway and install it by running the command:"
    echo ""
    echo "    chmod a+x install_${client}.shar"
    echo "    sudo ./install_${client}.shar"
    echo ""
}


# MAIN starts here
# Process options

while getopts hr:s:x c ; do
    case $c in
        h) usage ; exit 0 ;;
        r) opt_r="$OPTARG" ; isroot ; restore_server_config $opt_r ; exit $? ;;
        s) opt_s="$OPTARG" ; isroot ; save_server_config $opt_s ; exit $? ;;
        x) set -x ;;
        \?) usage ; >&2 echo"unknown option: $c" ; exit 1 ;;
    esac
done

isroot

if [[ ! -e ${SERVERDIR}/server.conf ]]; then
    clear
    echo 'Welcome to this Dali DMC Access Server installer!'
    echo "The network interfaces will be reconfigured first to use netplan and networkd"
    if detect_qotom ; then
        echo "This appears to be a Qotom network applicance"
        echo "    interface 1 should be connected to the Internet/Modem"
        echo "    interfaces 3 and 4 should be connected to the DMC"
        wanif='enp1s0'
        dmc_interfaces="enp3s0 enp4s0"
    else
        select_wan_interface
        select_dmc_interfaces
    fi
    echo "Using WAN interface $wanif"
    echo "Using DMC interface(s) $dmc_interfaces"
    create_wan_if $wanif
    # If system has a single IPv4, it is selected automatically. Else, ask the user
    if [[ $(ip -4 addr | grep inet | grep -vEc '127(\.[0-9]{1,3}){3}') -eq 1 ]]; then
        ip=$(ip -4 addr | grep inet | grep -vE '127(\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}')
    else
        number_of_ip=$(ip -4 addr | grep inet | grep -vEc '127(\.[0-9]{1,3}){3}')
        echo
        echo "Which IPv4 address should be used?"
        ip -4 addr | grep inet | grep -vE '127(\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}' | nl -s ') '
        read -p "IPv4 address [1]: " ip_number
        until [[ -z "$ip_number" || "$ip_number" =~ ^[0-9]+$ && "$ip_number" -le "$number_of_ip" ]]; do
            echo "$ip_number: invalid selection."
            read -p "IPv4 address [1]: " ip_number
        done
        [[ -z "$ip_number" ]] && ip_number="1"
        ip=$(ip -4 addr | grep inet | grep -vE '127(\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}' | sed -n "$ip_number"p)
    fi
    #Â If $ip is a private IP address, the server must be behind NAT
    if echo "$ip" | grep -qE '^(10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.|192\.168)'; then
        echo
        echo "This server is behind NAT. What is the public IPv4 address or hostname?"
        # Get public IP and sanitize with grep
        get_public_ip=$(grep -m 1 -oE '^[0-9]{1,3}(\.[0-9]{1,3}){3}$' <<< "$(wget -T 10 -t 1 -4qO- "http://ip1.dynupdate.no-ip.com/" || curl -m 10 -4Ls "http://ip1.dynupdate.no-ip.com/")")
        read -p "Public IPv4 address / hostname [$get_public_ip]: " public_ip
        # If the checkip service is unavailable and user didn't provide input, ask again
        until [[ -n "$get_public_ip" || -n "$public_ip" ]]; do
            echo "Invalid input."
            read -p "Public IPv4 address / hostname: " public_ip
        done
        [[ -z "$public_ip" ]] && public_ip="$get_public_ip"
    fi
    # If system has a single IPv6, it is selected automatically
    if [[ $(ip -6 addr | grep -c 'inet6 [23]') -eq 1 ]]; then
        ip6=$(ip -6 addr | grep 'inet6 [23]' | cut -d '/' -f 1 | grep -oE '([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}')
    fi
    # If system has multiple IPv6, ask the user to select one
    if [[ $(ip -6 addr | grep -c 'inet6 [23]') -gt 1 ]]; then
        number_of_ip6=$(ip -6 addr | grep -c 'inet6 [23]')
        echo
        echo "Which IPv6 address should be used?"
        ip -6 addr | grep 'inet6 [23]' | cut -d '/' -f 1 | grep -oE '([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}' | nl -s ') '
        read -p "IPv6 address [1]: " ip6_number
        until [[ -z "$ip6_number" || "$ip6_number" =~ ^[0-9]+$ && "$ip6_number" -le "$number_of_ip6" ]]; do
            echo "$ip6_number: invalid selection."
            read -p "IPv6 address [1]: " ip6_number
        done
        [[ -z "$ip6_number" ]] && ip6_number="1"
        ip6=$(ip -6 addr | grep 'inet6 [23]' | cut -d '/' -f 1 | grep -oE '([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}' | sed -n "$ip6_number"p)
    fi
    echo
    echo "Which protocol should DMC Access Server use?"
    echo "   1) UDP (recommended)"
    echo "   2) TCP"
    read -p "Protocol [1]: " protocol
    until [[ -z "$protocol" || "$protocol" =~ ^[12]$ ]]; do
        echo "$protocol: invalid selection."
        read -p "Protocol [1]: " protocol
    done
    case "$protocol" in
        1|"") 
        protocol=udp
        ;;
        2) 
        protocol=tcp
        ;;
    esac
    echo
    echo "What port should DMC Access Server listen to?"
    read -p "Port [1194]: " port
    until [[ -z "$port" || "$port" =~ ^[0-9]+$ && "$port" -le 65535 ]]; do
        echo "$port: invalid port."
        read -p "Port [1194]: " port
    done
    [[ -z "$port" ]] && port="1194"
    echo
    echo "Select a DNS server for the gateways:"
    echo "   1) Current system resolvers"
    echo "   2) Google"
    echo "   3) 1.1.1.1"
    echo "   4) OpenDNS"
    echo "   5) Quad9"
    echo "   6) AdGuard"
    read -p "DNS server [1]: " dns
    until [[ -z "$dns" || "$dns" =~ ^[1-6]$ ]]; do
        echo "$dns: invalid selection."
        read -p "DNS server [1]: " dns
    done
    echo
    echo "Enter a name for the first gateway:"
    read -p "Name [gateway]: " unsanitized_client
    # Allow a limited set of characters to avoid conflicts
    client=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_client")
    [[ -z "$client" ]] && client="gateway"
    echo
    if [ ! -f $STATEDIR/.snmpauth ] ; then
        echo "Enter a user name for SNMPv3 monitoring:"
        read -p "SNMP user name [dali]: " unsanitized_snmp_user
        # Allow a limited set of characters to avoid conflicts
        snmp_user=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_snmp_user")
        [[ -z "$snmp_user" ]] && snmp_user="dali"
        echo "Using SNMP user name (on server and gateways for both authentication and privacy): \"$snmp_user\""
        echo
        echo "Enter a password for SNMPv3 monitoring:"
        read -p "SNMP password [dali1234]: " unsanitized_snmp_password
        # Allow a limited set of characters to avoid conflicts
        snmp_password=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_snmp_password")
        [[ -z "$snmp_password" ]] && snmp_password="dali1234"
        echo "Using SNMP password (on server and gateways for both authentication and privacy): \"$snmp_password\""
        echo
    fi
    echo "DMC Access Server installation is ready to begin."
    read -n1 -r -p "Press any key to continue..."
    create_dmc_lanbr $dmc_interfaces
    # Install a firewall in the rare case where one is not already available
    if ! systemctl is-active --quiet firewalld.service && ! hash iptables 2>/dev/null; then
        if [[ "$os" == "centos" || "$os" == "fedora" ]]; then
            firewall="firewalld"
            # We don't want to silently enable firewalld, so we give a subtle warning
            # If the user continues, firewalld will be installed and enabled during setup
            echo "firewalld, which is required to manage routing tables, will also be installed."
        elif [[ "$os" == "debian" || "$os" == "ubuntu" ]]; then
            # iptables is way less invasive than firewalld so no warning is given
            firewall="iptables"
        fi
    fi
    # If running inside a container, disable LimitNPROC to prevent conflicts
    if systemd-detect-virt -cq; then
        mkdir /etc/systemd/system/openvpn-server@server.service.d/ 2>/dev/null
        echo "[Service]
LimitNPROC=infinity" > /etc/systemd/system/openvpn-server@server.service.d/disable-limitnproc.conf
    fi
    if [[ "$os" = "debian" || "$os" = "ubuntu" ]]; then
        apt-get update
        apt-get install -y ipcalc openvpn openssl ca-certificates $firewall
        snap install yq
    elif [[ "$os" = "centos" ]]; then
        yum install -y epel-release
        yum install -y openvpn openssl ca-certificates tar $firewall
    else
        # Else, OS must be Fedora
        dnf install -y openvpn openssl ca-certificates tar $firewall
    fi
    # If firewalld was just installed, enable it
    if [[ "$firewall" == "firewalld" ]]; then
        systemctl enable --now firewalld.service
    fi

    VPNSERVER=$(ipcalc -nb ${VPNNET} | awk '/^Address:/{printf "%s ", $2}; /^Netmask:/{print $2}')

    # Get easy-rsa
    easy_rsa_url='https://github.com/OpenVPN/easy-rsa/releases/download/v3.0.8/EasyRSA-3.0.8.tgz'
    mkdir -p ${SERVERDIR}/easy-rsa/
    { wget -qO- "$easy_rsa_url" 2>/dev/null || curl -sL "$easy_rsa_url" ; } | tar xz -C ${SERVERDIR}/easy-rsa/ --strip-components 1
    chown -R root:root ${SERVERDIR}/easy-rsa/
    cd ${SERVERDIR}/easy-rsa/
    # Create the PKI, set up the CA and the server and client certificates
    ./easyrsa init-pki
    ./easyrsa --batch build-ca nopass
    EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-server-full server nopass
    EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-client-full "$client" nopass
    EASYRSA_CRL_DAYS=3650 ./easyrsa gen-crl
    # Move the stuff we need
    cp pki/ca.crt pki/private/ca.key pki/issued/server.crt pki/private/server.key pki/crl.pem ${SERVERDIR}
    # CRL is read with each client connection, while OpenVPN is dropped to nobody
    chown nobody:"$group_name" ${SERVERDIR}/crl.pem
    # Without +x in the directory, OpenVPN can't run a stat() on the CRL file
    chmod o+x ${SERVERDIR}/
    # Generate key for tls-crypt
    openvpn --genkey --secret ${SERVERDIR}/tc.key
    # Create the DH parameters file using the predefined ffdhe2048 group
    echo '-----BEGIN DH PARAMETERS-----
MIIBCAKCAQEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz
+8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a
87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7
YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi
7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaD
ssbzSibBsu/6iGtCOGEoXJf//////////wIBAg==
-----END DH PARAMETERS-----' > ${SERVERDIR}/dh.pem
    # Generate server.conf
    echo "local $ip
port $port
proto $protocol
dev tun
ca ca.crt
cert server.crt
key server.key
dh dh.pem
auth SHA512
tls-crypt tc.key
topology subnet
server ${VPNSERVER}" > ${SERVERDIR}/server.conf
    # IPv6
    if [[ -z "$ip6" ]]; then
        echo 'push "redirect-gateway def1 bypass-dhcp"' >> ${SERVERDIR}/server.conf
    else
        echo 'server-ipv6 fddd:1194:1194:1194::/64' >> ${SERVERDIR}/server.conf
        echo 'push "redirect-gateway def1 ipv6 bypass-dhcp"' >> ${SERVERDIR}/server.conf
    fi
    echo "client-config-dir ${CCDDIR}" >> ${SERVERDIR}/server.conf
    mkdir -p ${CCDDIR}
    # DNS
    case "$dns" in
        1|"")
            # Locate the proper resolv.conf
            # Needed for systems running systemd-resolved
            if grep -q '^nameserver 127.0.0.53' "/etc/resolv.conf"; then
                resolv_conf="/run/systemd/resolve/resolv.conf"
            else
                resolv_conf="/etc/resolv.conf"
            fi
            # Obtain the resolvers from resolv.conf and use them for OpenVPN
            grep -v '^#\|^;' "$resolv_conf" | grep '^nameserver' | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}' | while read line; do
                echo "push \"dhcp-option DNS $line\"" >> ${SERVERDIR}/server.conf
            done
        ;;
        2)
            echo 'push "dhcp-option DNS 8.8.8.8"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 8.8.4.4"' >> ${SERVERDIR}/server.conf
        ;;
        3)
            echo 'push "dhcp-option DNS 1.1.1.1"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 1.0.0.1"' >> ${SERVERDIR}/server.conf
        ;;
        4)
            echo 'push "dhcp-option DNS 208.67.222.222"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 208.67.220.220"' >> ${SERVERDIR}/server.conf
        ;;
        5)
            echo 'push "dhcp-option DNS 9.9.9.9"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 149.112.112.112"' >> ${SERVERDIR}/server.conf
        ;;
        6)
            echo 'push "dhcp-option DNS 94.140.14.14"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 94.140.15.15"' >> ${SERVERDIR}/server.conf
        ;;
    esac
    echo "keepalive 10 120
cipher AES-256-CBC
user nobody
group $group_name
persist-key
persist-tun
verb 3
compress lz4-v2
push \"compress lz4-v2\"
crl-verify crl.pem" >> ${SERVERDIR}/server.conf
    if [[ "$protocol" = "udp" ]]; then
        echo "explicit-exit-notify" >> ${SERVERDIR}/server.conf
    fi
    # Enable net.ipv4.ip_forward for the system
    echo 'net.ipv4.ip_forward=1' > /etc/sysctl.d/30-openvpn-forward.conf
    # Enable without waiting for a reboot or service restart
    echo 1 > /proc/sys/net/ipv4/ip_forward
    if [[ -n "$ip6" ]]; then
        # Enable net.ipv6.conf.all.forwarding for the system
        echo "net.ipv6.conf.all.forwarding=1" >> /etc/sysctl.d/30-openvpn-forward.conf
        # Enable without waiting for a reboot or service restart
        echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
    fi
    if systemctl is-active --quiet firewalld.service; then
        # Using both permanent and not permanent rules to avoid a firewalld
        # reload.
        # We don't use --add-service=openvpn because that would only work with
        # the default port and protocol.
        firewall-cmd --add-port="$port"/"$protocol"
        firewall-cmd --zone=trusted --add-source=${VPNNET}
        firewall-cmd --permanent --add-port="$port"/"$protocol"
        firewall-cmd --permanent --zone=trusted --add-source=${VPNNET}
        # Set NAT for the VPN subnet
        firewall-cmd --direct --add-rule ipv4 nat POSTROUTING 0 -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to "$ip"
        firewall-cmd --permanent --direct --add-rule ipv4 nat POSTROUTING 0 -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to "$ip"
        if [[ -n "$ip6" ]]; then
            firewall-cmd --zone=trusted --add-source=fddd:1194:1194:1194::/64
            firewall-cmd --permanent --zone=trusted --add-source=fddd:1194:1194:1194::/64
            firewall-cmd --direct --add-rule ipv6 nat POSTROUTING 0 -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to "$ip6"
            firewall-cmd --permanent --direct --add-rule ipv6 nat POSTROUTING 0 -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to "$ip6"
        fi
    else
        # Create a service to set up persistent iptables rules
        iptables_path=$(command -v iptables)
        ip6tables_path=$(command -v ip6tables)
        # nf_tables is not available as standard in OVZ kernels. So use iptables-legacy
        # if we are in OVZ, with a nf_tables backend and iptables-legacy is available.
        if [[ $(systemd-detect-virt) == "openvz" ]] && readlink -f "$(command -v iptables)" | grep -q "nft" && hash iptables-legacy 2>/dev/null; then
            iptables_path=$(command -v iptables-legacy)
            ip6tables_path=$(command -v ip6tables-legacy)
        fi
        echo "[Unit]
Before=network.target
[Service]
Type=oneshot
ExecStart=$iptables_path -t nat -A POSTROUTING -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to $ip
ExecStart=$iptables_path -I INPUT -p $protocol --dport $port -j ACCEPT
ExecStart=$iptables_path -I FORWARD -s ${VPNNET} -j ACCEPT
ExecStart=$iptables_path -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
ExecStop=$iptables_path -t nat -D POSTROUTING -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to $ip
ExecStop=$iptables_path -D INPUT -p $protocol --dport $port -j ACCEPT
ExecStop=$iptables_path -D FORWARD -s ${VPNNET} -j ACCEPT
ExecStop=$iptables_path -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT" > /etc/systemd/system/openvpn-iptables.service
        if [[ -n "$ip6" ]]; then
            echo "ExecStart=$ip6tables_path -t nat -A POSTROUTING -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to $ip6
ExecStart=$ip6tables_path -I FORWARD -s fddd:1194:1194:1194::/64 -j ACCEPT
ExecStart=$ip6tables_path -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
ExecStop=$ip6tables_path -t nat -D POSTROUTING -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to $ip6
ExecStop=$ip6tables_path -D FORWARD -s fddd:1194:1194:1194::/64 -j ACCEPT
ExecStop=$ip6tables_path -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT" >> /etc/systemd/system/openvpn-iptables.service
        fi
        echo "RemainAfterExit=yes
[Install]
WantedBy=multi-user.target" >> /etc/systemd/system/openvpn-iptables.service
        systemctl enable --now openvpn-iptables.service
    fi
    # If SELinux is enabled and a custom port was selected, we need this
    if sestatus 2>/dev/null | grep "Current mode" | grep -q "enforcing" && [[ "$port" != 1194 ]]; then
        # Install semanage if not already present
        if ! hash semanage 2>/dev/null; then
            if [[ "$os_version" -eq 7 ]]; then
                # Centos 7
                yum install -y policycoreutils-python
            else
                # CentOS 8 or Fedora
                dnf install -y policycoreutils-python-utils
            fi
        fi
        semanage port -a -t openvpn_port_t -p "$protocol" "$port"
    fi
    # If the server is behind NAT, use the correct IP address
    [[ -n "$public_ip" ]] && ip="$public_ip"
    # client-common.txt is created so we have a template to add further users later
    echo "client
dev tun
proto $protocol
remote $ip $port
resolv-retry infinite
nobind
persist-key
persist-tun
remote-cert-tls server
auth SHA512
cipher AES-256-CBC
ignore-unknown-option block-outside-dns
block-outside-dns
comp-lzo
verb 3" > ${SERVERDIR}/client-common.txt
    # Enable and start the OpenVPN service
    systemctl enable --now openvpn-server@server.service
    if [ ! -f $STATEDIR/.snmpauth ] ; then
        # Setup SNMP monitoring
        setup_server_snmpd "$snmp_user" "$snmp_password"
        echo "snmp_user=\"$snmp_user\"" > $STATEDIR/.snmpauth
        echo "snmp_password=\"$snmp_password\"" >> $STATEDIR/.snmpauth
    fi
    # Generates the custom client.ovpn
    new_client
    echo
    echo "Finished!"
    echo
    echo "New clients can be added by running this script again."
else
    clear
    echo "DMC Access Server is already installed."
    echo
    echo "Select an option:"
    echo "   1) Add a new remote gateway"
    echo "   2) Revoke an existing remote gateway"
    echo "   3) Remove DMC Access Server"
    echo "   4) Exit"
    read -p "Option: " option
    until [[ "$option" =~ ^[1-4]$ ]]; do
        echo "$option: invalid selection."
        read -p "Option: " option
    done
    case "$option" in
        1)
            echo
            echo "Provide a name for the gateway:"
            read -p "Name: " unsanitized_client
            client=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_client")
            while [[ -z "$client" || -e ${SERVERDIR}/easy-rsa/pki/issued/"$client".crt ]]; do
                echo "$client: invalid name."
                read -p "Name: " unsanitized_client
                client=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_client")
            done
            cd ${SERVERDIR}/easy-rsa/
            EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-client-full "$client" nopass
            # Generates the custom client.ovpn
            new_client
            exit
        ;;
        2)
            # This option could be documented a bit better and maybe even be simplified
            # ...but what can I say, I want some sleep too
            number_of_clients=$(tail -n +2 ${SERVERDIR}/easy-rsa/pki/index.txt | grep -c "^V")
            if [[ "$number_of_clients" = 0 ]]; then
                echo
                echo "There are no existing gateways!"
                exit
            fi
            echo
            echo "Select the gateway to revoke:"
            tail -n +2 ${SERVERDIR}/easy-rsa/pki/index.txt | grep "^V" | cut -d '=' -f 2 | nl -s ') '
            read -p "Gateway: " client_number
            until [[ "$client_number" =~ ^[0-9]+$ && "$client_number" -le "$number_of_clients" ]]; do
                echo "$client_number: invalid selection."
                read -p "Gateway: " client_number
            done
            client=$(tail -n +2 ${SERVERDIR}/easy-rsa/pki/index.txt | grep "^V" | cut -d '=' -f 2 | sed -n "$client_number"p)
            echo
            read -p "Confirm $client revocation? [y/N]: " revoke
            until [[ "$revoke" =~ ^[yYnN]*$ ]]; do
                echo "$revoke: invalid selection."
                read -p "Confirm $client revocation? [y/N]: " revoke
            done
            if [[ "$revoke" =~ ^[yY]$ ]]; then
                cd ${SERVERDIR}/easy-rsa/
                ./easyrsa --batch revoke "$client"
                EASYRSA_CRL_DAYS=3650 ./easyrsa gen-crl
                rm -f ${SERVERDIR}/crl.pem
                cp ${SERVERDIR}/easy-rsa/pki/crl.pem ${SERVERDIR}/crl.pem
                # CRL is read with each client connection, when OpenVPN is dropped to nobody
                chown nobody:"$group_name" ${SERVERDIR}/crl.pem
                echo
                destroy_tunnel $client
                echo "$client revoked!"
            else
                echo
                echo "$client revocation aborted!"
            fi
            exit
        ;;
        3)
            echo
            read -p "Confirm DMC Access Server removal? [y/N]: " remove
            until [[ "$remove" =~ ^[yYnN]*$ ]]; do
                echo "$remove: invalid selection."
                read -p "Confirm DMC Access Server removal? [y/N]: " remove
            done
            if [[ "$remove" =~ ^[yY]$ ]]; then
                port=$(grep '^port ' ${SERVERDIR}/server.conf | cut -d " " -f 2)
                protocol=$(grep '^proto ' ${SERVERDIR}/server.conf | cut -d " " -f 2)
                if systemctl is-active --quiet firewalld.service; then
                    ip=$(firewall-cmd --direct --get-rules ipv4 nat POSTROUTING | grep "\-s ${VPNNET} ""'"'!'"'"" -d ${VPNNET}" | grep -oE '[^ ]+$')
                    # Using both permanent and not permanent rules to avoid a firewalld reload.
                    firewall-cmd --remove-port="$port"/"$protocol"
                    firewall-cmd --zone=trusted --remove-source=${VPNNET}
                    firewall-cmd --permanent --remove-port="$port"/"$protocol"
                    firewall-cmd --permanent --zone=trusted --remove-source=${VPNNET}
                    firewall-cmd --direct --remove-rule ipv4 nat POSTROUTING 0 -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to "$ip"
                    firewall-cmd --permanent --direct --remove-rule ipv4 nat POSTROUTING 0 -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to "$ip"
                    if grep -qs "server-ipv6" ${SERVERDIR}/server.conf; then
                        ip6=$(firewall-cmd --direct --get-rules ipv6 nat POSTROUTING | grep '\-s fddd:1194:1194:1194::/64 '"'"'!'"'"' -d fddd:1194:1194:1194::/64' | grep -oE '[^ ]+$')
                        firewall-cmd --zone=trusted --remove-source=fddd:1194:1194:1194::/64
                        firewall-cmd --permanent --zone=trusted --remove-source=fddd:1194:1194:1194::/64
                        firewall-cmd --direct --remove-rule ipv6 nat POSTROUTING 0 -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to "$ip6"
                        firewall-cmd --permanent --direct --remove-rule ipv6 nat POSTROUTING 0 -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to "$ip6"
                    fi
                else
                    systemctl disable --now openvpn-iptables.service
                    rm -f /etc/systemd/system/openvpn-iptables.service
                fi
                if sestatus 2>/dev/null | grep "Current mode" | grep -q "enforcing" && [[ "$port" != 1194 ]]; then
                    semanage port -d -t openvpn_port_t -p "$protocol" "$port"
                fi
                systemctl disable --now openvpn-server@server.service
                rm -rf ${SERVERDIR}
                rm -f /etc/systemd/system/openvpn-server@server.service.d/disable-limitnproc.conf
                rm -f /etc/sysctl.d/30-openvpn-forward.conf
                restore_networking_default
                if [[ "$os" = "debian" || "$os" = "ubuntu" ]]; then
                    apt-get remove --purge -y openvpn
                else
                    # Else, OS must be CentOS or Fedora
                    yum remove -y openvpn
                fi
                echo
                echo "DMC Access Server removed!"
            else
                echo
                echo "DMC Access Server removal aborted!"
            fi
            exit
        ;;
        4)
            exit
        ;;
    esac
fi

