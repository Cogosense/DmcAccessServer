#!/bin/bash
#
# Copyright Dali Wireless 2021
#
# Based on the work:
#
# https://github.com/Nyr/openvpn-install
#
# Copyright (c) 2013 Nyr. Released under the MIT License.
shopt -s extglob
VPNNET=10.8.0.0/24
CFGDIR=/etc/openvpn
CCDDIR=${CFGDIR}/ccd
CLIENTDIR=${CFGDIR}/client
SERVERDIR=${CFGDIR}/server
TOOLDIR=$(cd $(dirname $0) && pwd)
STATEDIR=$TOOLDIR/state
GWYSTATEDIR=$STATEDIR/gateways
SVRSTATEDIR=$STATEDIR/server
: ${NETPLANDIR:=/etc/netplan}
progname=$(basename $0)
activate_wanif='yes'

opt_s=''
opt_r=''

usage() {
    cat << _EOF

"$progname" manage the DMC VPN server and remote gateways

Usage: sudo $0 [OPTIONS]
       $0 -h

When run without options $progname runs in an interactive mode. The use
of "sudo" is required for all actions except the help and create
configuration modes.

If this system is not installed in its final production location, use a
configuration  file to specify the parameters of the final installation.
A configuration file is created with the '-C' option. Then copy the config
file to the production system and activate with the '-c' option.

The first time it is run, the OVPN server, SNMP server, SSH server and the
network topology will be initialized and a first gateway config created.

Subsequent runs with no options can be used to add gateways and to revoke
gateways.

The following options can be used to mirror the configuration to a cold standby
DMC access server. The active server should be saved after any changes to the
remote gateway configuration, then restored on the standby side.

NOTE: On the standby side, a saved configuration should be restored  after
$progname has been run once. This will overwrite the initial gateway created in
the setup process on the standby side, and will render the standby a clone of the
active DMC access server. The initial setup is required to ensure the necessary
software packages are installed.

OPTIONS:

 -h               This help screen (does not require sudo)
 -C  [CFGFILE]    Create a new configuration file and exits
 -c  [CFGFILE]    Apply a previously created configuration file
 -s  [IP|TARFILE] Save server config directly to IP address, or save to TARFILE
                  for manual transfer to standby system.
 -r  [TARFILE]    Restore DMC access server config from the TARFILE.
 -x               Turn on bash shell tracing.

_EOF
}

[ -d $STATEDIR ] || mkdir $STATEDIR
[ -f $STATEDIR/.snmpauth ] && . $STATEDIR/.snmpauth

# Detect Debian users running the script with "sh" instead of bash
if readlink /proc/$$/exe | grep -q "dash"; then
    echo 'This installer needs to be run with "bash", not "sh".'
    exit
fi

# Discard stdin. Needed when running from an one-liner which includes a newline
read -N 999999 -t 0.001

# Detect OpenVZ 6
if [[ $(uname -r | cut -d "." -f 1) -eq 2 ]]; then
    echo "The system is running an old kernel, which is incompatible with this installer."
    exit
fi

# Detect OS
# $os_version variables aren't always in use, but are kept here for convenience
if grep -qs "alpine" /etc/os-release; then
    os="alpine"
    os_version=$(grep 'VERSION_ID' /etc/os-release | cut -d '"' -f 2 | tr -d '.')
    group_name="nogroup"
elif grep -qs "ubuntu" /etc/os-release; then
    os="ubuntu"
    os_version=$(grep 'VERSION_ID' /etc/os-release | cut -d '"' -f 2 | tr -d '.')
    group_name="nogroup"
elif [[ -e /etc/debian_version ]]; then
    os="debian"
    os_version=$(grep -oE '[0-9]+' /etc/debian_version | head -1)
    group_name="nogroup"
elif [[ -e /etc/centos-release ]]; then
    os="centos"
    os_version=$(grep -oE '[0-9]+' /etc/centos-release | head -1)
    group_name="nobody"
elif [[ -e /etc/fedora-release ]]; then
    os="fedora"
    os_version=$(grep -oE '[0-9]+' /etc/fedora-release | head -1)
    group_name="nobody"
else
    echo "This installer seems to be running on an unsupported distribution.
Supported distributions are Ubuntu, Debian, CentOS, and Fedora."
    exit
fi

if [[ "$os" == "ubuntu" && "$os_version" -lt 1804 ]]; then
    echo "Ubuntu 18.04 or higher is required to use this installer.
This version of Ubuntu is too old and unsupported."
    exit
fi

if [[ "$os" == "debian" && "$os_version" -lt 9 ]]; then
    echo "Debian 9 or higher is required to use this installer.
This version of Debian is too old and unsupported."
    exit
fi

if [[ "$os" == "centos" && "$os_version" -lt 7 ]]; then
    echo "CentOS 7 or higher is required to use this installer.
This version of CentOS is too old and unsupported."
    exit
fi

# Detect environments where $PATH does not include the sbin directories
if ! grep -q sbin <<< "$PATH"; then
    echo '$PATH does not include sbin. Try using "su -" instead of "su".'
    exit
fi

if [[ ! -e /dev/net/tun ]] || ! ( exec 7<>/dev/net/tun ) 2>/dev/null; then
    echo "The system does not have the TUN device available.
TUN needs to be enabled before running this installer."
    exit
fi

isroot() {
    if [[ "$EUID" -ne 0 ]]; then
        echo "This installer needs to be run with superuser privileges."
        exit
    fi
}

ip2dec() {
    declare -i a b c d
    IFS=. read a b c d <<<"$1"
    echo "$(((10#$a<<24)+(10#$b<<16)+(10#$c<<8)+10#$d))"
}

dec2ip() {
    local ip=$1
    local i s
    for i in {1..4}; do
        s='.'$((ip%256))$s && ((ip>>=8))
    done
    echo ${s:1}
}

ipv4address_get() {
    local prompt=$1
    local address=""
    while : ; do
        read -p "$prompt (N.N.N.N, N is 0-255) " address
        case $address in
            "") break ;;
            +([0-9]).+([0-9]).+([0-9]).+([0-9]))
                o1=${address%%.*}
                octets=${address#*.}
                o2=${octets%%.*}
                octets=${octets#*.}
                o3=${octets%%.*}
                o4=${octets##*.}

                for octet in "$o1" "$o2" "$o3" "$o4" ; do
                    if [ $octet -gt 255 ] ; then
                        >&2 echo "$address is invalid, the part $octet must be less than 255"
                        address=''
                        break
                    fi
                done

                if [ -n "$address" ] ; then
                    read -p "The provided internet address is $address ? [yn] " reply
                    case $reply in
                        [Yy]*) ;;
                        *) address='' ;;
                    esac
                fi
                ;;
            *) >&2 echo "Did not recognize address format, Should be N.N.N.N format" ; echo ; address='' ;;
        esac
        if [ -n "$address" ] ; then
            break
        fi
    done
    echo "$address"
}

#
# Select the interface configuration method
# The following variable is set on return:
# - proto
#
wanifproto_get() {
    proto=""
    while : ; do
        read -p "Will the WAN interface be manually or automatically configured? (static|dhcp) " proto
        case $proto in
            "") read -p "The WAN interface configuration method will be determined at installation time? [yn] " reply
                case $reply in
                    [Yy]*) break ;;
                    *) ;;
                esac
                ;;
            static) read -p "The WAN interface configuration will be manual? [yn] " reply
                case $reply in
                    [Yy]*) ;;
                    *) proto="" ;;
                esac
                ;;
            dhcp) read -p "The WAN interface configuration will be automatic? [yn] " reply
                case $reply in
                    [Yy]*) ;;
                    *) proto="" ;;
                esac
                ;;
        esac
        if [ -n "$proto" ] ; then
            break
        fi
    done
}

#
# This method sets the following variables
# on return.
# - address (IPv4 address)
# - netmask (as bit count)
# - gateway (IPv4 address)
# - nameservers (comma seperated list of IPv4 addresses)
# - activate_wanif (yes|no)
#
staticifinfo_get() {
    local reply=''
    address=""
    while : ; do
        address=$(ipv4address_get "What is the IPv4 address of the WAN interface?")
        if [ -n "$address" ] ; then
            break
        else
            echo "The WAN interface address must be provided when using manual interface configuration"
        fi
    done
    echo

    netmask=""
    while : ; do
        read -p "Enter the number of bits in the netmask? [8-30] " netmask
        case $netmask in
            "") echo "The WAN interface netmask must be provided when using manual interface configuration" ; echo ; netmask='' ;;
            8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30) read -p "The WAN interface netmask is $netmask bits? [yn] " reply
                case $reply in
                    [Yy]*) ;;
                    *) netmask='' ;;
                esac
                ;;
            *) echo 'The number of bits is invalid, provide a number between 8 and 30 inclusive' ; echo ; netmask='' ;;
        esac
        if [ -n "$netmask" ] ; then
            break
        fi
    done
    echo

    gateway=""
    while : ; do
        gateway=$(ipv4address_get "What is the IPv4 address of the WAN gateway?")
        if [ -n "$gateway" ] ; then
            break
        else
            echo "The WAN gateway address must be provided when using manual interface configuration"
        fi
    done
    echo

    nameservers=""
    local nameserver=''
    while : ; do
        nameserver=$(ipv4address_get "What is the IPv4 address of the WAN name server?")
        if [ -z "$nameserver" ] ; then
            echo "The WAN nameserver address must be provided when using manual interface configuration"
            continue
        fi
        nameservers="$nameservers$nameserver"
        read -p "Add another nameserver? [yn] " reply
        case $reply in
            [Yy]*) nameservers="$nameservers," ;;
            *) break ;;
        esac
    done
    echo

    activate_wanif=""
    while : ; do
        read -p "Activate the WAN interface before configuring? [yes] " activate_wanif
        case $netmask in
            "") activate_wanif='yes' ;;
            y*|Y*) activate_wanif='yes' ;;
            n*|N*) activate_wanif='no' ;;
            *) echo 'The answer is yes or no' ; echo ; activate_wanif='' ;;
        esac
        if [ -n "$activate_wanif" ] ; then
            break
        fi
    done
    echo
}

#
# Get the VPN transport protocol and port
# on return the following variables are set
# - protocol (tcp|udp)
# - port
#
vpn_protocol_get() {
    echo "Which protocol should DMC Access Server use?"
    echo "   1) UDP (recommended)"
    echo "   2) TCP"
    read -p "Protocol [1]: " protocol
    until [[ -z "$protocol" || "$protocol" =~ ^[12]$ ]]; do
        echo "$protocol: invalid selection."
        read -p "Protocol [1]: " protocol
    done
    case "$protocol" in
        1|"") 
        protocol=udp
        ;;
        2) 
        protocol=tcp
        ;;
    esac
    echo
    echo "What port should DMC Access Server listen to?"
    read -p "Port [1194]: " port
    until [[ -z "$port" || "$port" =~ ^[0-9]+$ && "$port" -le 65535 ]]; do
        echo "$port: invalid port."
        read -p "Port [1194]: " port
    done
    [[ -z "$port" ]] && port="1194"
}

#
# Get the DNS server option to be used by the gateway
# On return the following variable is set:
# - dns (the gateway DNS option)
#    1) Current system resolvers
#    2) Google
#    3) 1.1.1.1
#    4) OpenDNS
#    5) Quad9
#    6) AdGuard
#
vpn_gateway_dns_option_get() {
    echo "Select a DNS server for the gateways:"
    echo "   1) Current system resolvers"
    echo "   2) Google"
    echo "   3) 1.1.1.1"
    echo "   4) OpenDNS"
    echo "   5) Quad9"
    echo "   6) AdGuard"
    read -p "DNS server [1]: " dns
    until [[ -z "$dns" || "$dns" =~ ^[1-6]$ ]]; do
        echo "$dns: invalid selection."
        read -p "DNS server [1]: " dns
    done
    [[ -z "$dns" ]] && dns=1
}

#
# Get the first client name to be created on install
# On return the following variable is set:
# - client (name of first gatway)
#
first_client_name_get() {
    echo "Enter a name for the first gateway:"
    read -p "Name [gateway]: " unsanitized_client
    # Allow a limited set of characters to avoid conflicts
    client=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_client")
    [[ -z "$client" ]] && client="gateway"
}

#
# Get the user and password for SNMPv3 authentication
# On return the following variables are set
# - snmp_user (the SNMPv3 user name)
# - snmp_password (the SNMPv3 user password)
#
snmp_user_get() {
    echo "Enter a user name for SNMPv3 monitoring:"
    read -p "SNMP user name [dali]: " unsanitized_snmp_user
    # Allow a limited set of characters to avoid conflicts
    snmp_user=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_snmp_user")
    [[ -z "$snmp_user" ]] && snmp_user="dali"
    echo "Using SNMP user name \"$snmp_user\" (on both server and gateways for both authentication and privacy)"
    echo
    echo "Enter a password for SNMPv3 monitoring:"
    read -p "SNMP password [dali1234]: " unsanitized_snmp_password
    # Allow a limited set of characters to avoid conflicts
    snmp_password=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_snmp_password")
    [[ -z "$snmp_password" ]] && snmp_password="dali1234"
    echo "Using SNMP password \"$snmp_password\" (on both server and gateways for both authentication and privacy)"
}

create_config() {
    local cfgfile=$1

    local wanif=""
    while : ; do
        read -p "Which interface is connected to the Internet? " wanif
        case $wanif in
            "")
                read -p "The WAN interface should be determined at installation time? [yn] " reply
                case $reply in
                    [Yy]*) break ;;
                    *) ;;
                esac
                ;;
            *)
                read -p "The internet facing interface will be named $wanif? [yn] " reply
                case $reply in
                    [Yy]*) ;;
                    *) wanif="" ;;
                esac
                ;;
        esac
        if [ -n "$wanif" ] ; then
            break
        fi
    done
    echo

    local lanifs=""
    while : ; do
        read -p "Which interface(s) are connected to the DMC(s)? (comma seperate multiple interface names, no spaces) " lanifs
        case $lanifs in
            "") read -p "The LAN interfaces should be determined at installation time? " reply
                case $reply in
                    [Yy]*) break ;;
                    *) ;;
                esac
                ;;
            *,*) read -p "The DMC facing interfaces are named $lanifs? [yn] " reply
                case $reply in
                    [Yy]*) ;;
                    *) lanifs="" ;;
                esac
                ;;
            *) read -p "The DMC facing interface is named $lanifs? [yn] " reply
                case $reply in
                    [Yy]*) ;;
                    *) lanifs="" ;;
                esac
                ;;
        esac
        if [ -n "$lanifs" ] ; then
            break
        fi
    done
    echo

    wanifproto_get
    echo

    if [ $proto == 'static' ] ;then
        staticifinfo_get
    fi

    local public_address=""
    while : ; do
        public_address=$(ipv4address_get "What is the public IPv4 address of the VPN server?")
        case $public_address in
            "")
                read -p "The VPN server address should be determined at installation time? [yn] " reply
                case $reply in
                    [Yy]*) break ;;
                    *) ;;
                esac
                ;;
        esac
        if [ -n "$public_address" ] ; then
            break
        fi
    done

    vpn_protocol_get
    echo

    vpn_gateway_dns_option_get
    echo

    first_client_name_get
    echo

    snmp_user_get
    echo

    cat << __EOF > $cfgfile
# Run ./dmc-access-server -C to create a new
# configuration file.

# WANIF
# the interface name of the WAN interface

WANIF=$wanif

# LANIFS
# a list of comma delimited interface names on the LAN side
# All these interfaces will be joined into a bridge and can
# be used to connect to individual DMC's or multiple links
# to a single DMC

LANIFS=$lanifs

#
# PROTO
# Set static for statically configured WAN interface
# Set dhcp for dynamically configured WAN interface
#
PROTO=$proto

#
# * ADDRESS - static IPv4 address of the WAN interface
# * NETMASK - netmask of the network connected to the WAN interface
# * GATEWAY - IP address of default gateway on the WAN interface
# * NAMESERVERS - IP address of the DNS servers, a comma seperated list
#
# If PROTO is static the following parameters are required:
# If PROTO is dynamic and the above parameters are set, the automatic
# detection features of this script are disabled and the manually
# configured values are used.

ADDRESS=$address
NETMASK=$netmask
GATEWAY=$gateway
NAMESERVERS=$nameservers

#
# ACTIVATE_WANIF
# Activate the WAN interface prior to proceeding with
# configuration. This is required if the WAN is required
# to connect to the internet. (If using port 2 to connect
# this option should be set to no.)

ACTIVATE_WANIF=$activate_wanif

#
# PUBLIC_ADDRESS
# The public IP address can be automatically determined if the server
# is connected to the network and the Internet is accessible. Otherwise
# the public IP address can be configured. Configuring a public IP
# address disables the automatic detection.

PUBLIC_ADDRESS=$public_address

#
# PROTOCOL
# The VPN transport protocol, either tcp or udp

PROTOCOL=$protocol

#
# PORT
# The VPN server port number

PORT=$port

#
# DNS
# The gateway DNS option
#    1) Current system resolvers
#    2) Google
#    3) 1.1.1.1
#    4) OpenDNS
#    5) Quad9
#    6) AdGuard

DNS=$dns

#
# CLIENT
# The name of the first client gateway to be created

CLIENT=$client

#
# SNMP_USER
# The user name to use for SNMPv3 authentication

SNMP_USER=$snmp_user

#
# SNMP_PASSWORD
# The user password to use for SNMPv3 authentication

SNMP_PASSWORD=$snmp_password
__EOF
}

load_config() {
    local cfgfile=$1
    if [ -f "$cfgfile" ] ; then
        . "$cfgfile"
        wanif=$WANIF
        lanifs=$LANIFS
        proto=$PROTO
        address=$ADDRESS
        netmask=$NETMASK
        gateway=$GATEWAY
        nameservers=$NAMESERVERS
        activate_wanif=$ACTIVATE_WANIF
        public_address=$PUBLIC_ADDRESS
        protocol=$PROTOCOL
        port=$PORT
        dns=$DNS
        client=$CLIENT
        snmp_user=$SNMP_USER
        snmp_password=$SNMP_PASSWORD
    fi
}

detect_qotom() {
    interfaces=$(ip link | awk '/^[0-9]*: /{print substr($2, 1, length($2)-1)}')
    ifcnt=0
    for interface in $interfaces ; do
        case $interface in
            enp?s0)   ((ifcnt++)) ;;
        esac
    done
    motherboard=$(dmidecode -s baseboard-product-name)
    [ $ifcnt -eq 4 -a "$motherboard" == 'Aptio CRB' ]
    return $?
}

select_wanif()
{
    interfaces=($(ip link show | awk '/^[0-9]*: en/{print substr($2, 1, length($2)-1)}'))
    while : ; do
        wanif=$(ip route show default | awk '{print $5}')
        local cnt=1
        for intf in "${interfaces[@]}"; do
            echo "$cnt) $intf"
            let cnt++
        done
        read -p "Which interface is connected to the Internet [$wanif]: " reply
        case $reply in
            "") ;;
            *) wanif="${interfaces[((reply-1))]}" ;;
        esac
        if [ -n "$wanif" ] ; then
            break
        fi
    done
}

select_lanifs()
{
    echo "Which interface(s) are connected to the DMC?"
    interfaces=($(ip link show | awk '/^[0-9]*: en/{print substr($2, 1, length($2)-1)}' | grep -v lo | grep -v "$wanif"))
    local selected_interfaces=""
    while : ; do
        local cnt=1
        for intf in "${interfaces[@]}"; do
            if grep -q $intf <<< $selected_interfaces ; then
                echo "$cnt) * $intf"
            else
                echo "$cnt)   $intf"
            fi
            let cnt++
        done
        echo "$cnt)   Done"
        read -p "Select interfaces toward DMC? [${selected_interfaces:-none selected}]: " reply
        case $reply in
            $cnt) break 2 ;;
            *) 
                interface="${interfaces[((reply-1))]}"
                if grep -q $interface <<< $selected_interfaces ; then
                    selected_interfaces=$(sed "s/$interface//" <<< $selected_interfaces)
                else
                    selected_interfaces="$selected_interfaces $interface"
                fi
                set -- $selected_interfaces
                selected_interfaces="$*"
                ;;
        esac
    done

    if [ -z "$selected_interfaces" ] ; then
        echo "no DMC interface selected"
        exit
    fi
    lanifs=$(sed 's/[ ][ ]*/,/g' <<< $selected_interfaces)
}

create_wanif() {
    local wanif=$1
    shift
    if [ -f ${NETPLANDIR}/01-network-manager-all.yaml ] ; then
        rm ${NETPLANDIR}/01-network-manager-all.yaml
    fi
    if [ $proto == 'dhcp' ] ; then
        cat < ${TOOLDIR}/templates/server/netplan/00-wan-config.tmpl | wanif="$wanif" envsubst > ${NETPLANDIR}/00-wan-config.yaml
    else
        cat < ${TOOLDIR}/templates/server/netplan/00-wan-static-config.tmpl | wanif="$wanif" address=$address netmask=$netmask gateway=$gateway nameservers=$nameservers envsubst > ${NETPLANDIR}/00-wan-static-config.yaml
    fi
    if [ $activate_wanif == 'yes' ] ; then
        echo "Activating WAN Interface before proceeding with configuration"
        netplan generate
        netplan apply
        while [ -z "$(ip -4 addr show $wanif | awk '/inet/{print $2}')" ] ; do : ; done
    fi
}

create_dmc_lanbr() {
    local interfaces="$@"
    (
        IFS=,
        local ethernets
        for interface in $interfaces ; do
            ethernets="$ethernets $(interface=$interface envsubst < ${TOOLDIR}/templates/server/netplan/dmc_ethernet.tmpl)"
        done
        cat < ${TOOLDIR}/templates/server/netplan/30-bridge-config.tmpl | ethernets="$ethernets" interfaces="$interfaces" envsubst > ${NETPLANDIR}/30-bridge-config.yaml
    )
    netplan generate
    netplan apply
}

add_tunnel_to_lanbr() {
    local tunnel=$1
    shift
    if ! grep -q "interfaces:[ ]*\[.*${tunnel}.*]"  ${NETPLANDIR}/30-bridge-config.yaml ; then
        cat ${NETPLANDIR}/30-bridge-config.yaml | yq e ".network.bridges.lanbr0.interfaces += \"${tunnel}\"" - > $$.yaml
        mv $$.yaml ${NETPLANDIR}/30-bridge-config.yaml
    fi
}

del_tunnel_from_lanbr() {
    local tunnel=$1
    shift
    if grep -q "interfaces:[ ]*\[.*${tunnel}.*]"  ${NETPLANDIR}/30-bridge-config.yaml ; then
        # yq hasn't implemented '-=' support yet
        interfaces=$(cat ${NETPLANDIR}/30-bridge-config.yaml | yq e ".network.bridges.lanbr0.interfaces" - | sed -r "s/ ?\b${tunnel}\b,?//;s/,,/,/;s/\[ /\[/;s/,]/]/")
        sed -i.bak "s/interfaces:.*$/interfaces: ${interfaces}/" ${NETPLANDIR}/30-bridge-config.yaml
        rm ${NETPLANDIR}/30-bridge-config.yaml.bak
    fi
}

get_current_lanbr_slaves() {
    ip link show master lanbr0 | awk '/^[0-9]*: (en|gre)/{print substr($2, 1, length($2)-1)}' | sed 's/@NONE//'
}

get_next_gretap_device() {
    slaves=`get_current_lanbr_slaves`
    # start gretap devices at 1 (0 can't be used)
    cnt=1
    for (( ; ; cnt++ ))
    do
        tunnel=gretap${cnt}
        if grep -q $tunnel <<< $slaves ; then
            continue
        fi
        echo $tunnel
        break
    done
}

create_tunnel() {
    local name=$1
    shift
    local clientip=$1
    shift
    local serverip=$1
    shift

    if [ ! -f ${NETPLANDIR}/20-tunnel-${name}.yaml ] ; then
        local tunnel=`get_next_gretap_device`
        cat < ${TOOLDIR}/templates/server/netplan/20-tunnel-remotegw-n.tmpl | tunnel="$tunnel" clientip="$clientip" serverip="$serverip" envsubst > ${NETPLANDIR}/20-tunnel-${name}.yaml
        add_tunnel_to_lanbr $tunnel
        netplan generate
        netplan apply
    fi
}

destroy_tunnel() {
    local name=$1
    shift
    if [ -f ${NETPLANDIR}/20-tunnel-${name}.yaml ] ; then
        tunnel=$(cat ${NETPLANDIR}/20-tunnel-${name}.yaml | yq e ".network.tunnels" - | head -1 | sed 's/:$//')
        del_tunnel_from_lanbr $tunnel
        rm ${NETPLANDIR}/20-tunnel-${name}.yaml
        netplan generate
        netplan apply
    fi
}

restore_networking_default() {
    rm ${NETPLANDIR}/*.yaml
    cat < ${TOOLDIR}/templates/server/netplan/01-network-manager-all.tmpl > ${NETPLANDIR}/01-network-manager-all.yaml
    netplan generate
    netplan apply
}

get_server_ip() {
    echo $(ipcalc -nb ${VPNNET} | awk '/HostMin:/{print $2}')
}

get_client_ip() {
    addr_pool=()
    reserved_ips=()
    minhost=$(ipcalc -nb ${VPNNET} | awk '/HostMin:/{print $2}')
    maxhost=$(ipcalc -nb ${VPNNET} | awk '/HostMax:/{print $2}')
    lower=$(ip2dec $minhost)
    upper=$(ip2dec $maxhost)

    for ((i=lower;i<=upper;i++)); do
        addr_pool+=($i)
    done

    reserved_ips+=($lower)

    for client in ${CCDDIR}/* ; do
        if [ -e $client ] ; then
            clientip=$(awk '/^ifconfig-push/{print $2}' $client)
            reserved_ips+=($(ip2dec $clientip))
        fi
    done

    for ip in ${addr_pool[@]}; do
        for reserved in ${reserved_ips[@]}; do
            if [[ $ip -eq $reserved ]] ; then
                continue 2
            fi
        done
        dec2ip $ip
        break
    done
}

save_server_config() {
    local dest=$1
    shift
    case "$dest" in
        *.tar|*.tar.gz|*.tar.bz2|*.tar.xz) tarfile="$dest" ;;
        *)
            if nc -zw 5 "$dest" 22 ; then
                tarfile="state-$(date --iso-8601=minutes | tr ':' '-').tar.gz"
                host="$dest"
            else
                tarfile="$dest.tar.gz"
            fi
            ;;
    esac
    rm -rf $SVRSTATEDIR
    mkdir -p $SVRSTATEDIR
    cp -a $CFGDIR $SVRSTATEDIR
    cp -a $NETPLANDIR $SVRSTATEDIR
    tar cp -C $TOOLDIR -zf "$tarfile" state
    if [ -n "$host" ] ; then
        echo "Please enter the password for \"dali\" on the standby host"
        scp $tarfile dali@$host:
        echo "state archive \"$tarfile\" created and copied to the standby host dali@$host"
    else
        echo "state archive \"$tarfile\" created, please copy it to the standby host"
    fi
    echo "use the following command to import it to the standby host: "
    echo "        sudo ./dmc-access-mgr -r ~/$tarfile"
    echo
}

restore_server_config() {
    local tarfile=$1
    shift
    rm -rf $SVRSTATEDIR/netplan
    rm -rf $SVRSTATEDIR/openvpn
    cp ${SERVERDIR}/server.conf $SVRSTATEDIR/server.conf
    mkdir -p $SVRSTATEDIR
    if [ -f "$tarfile" ] ; then
        tar xp -C $TOOLDIR -f $tarfile
        rm -rf $CFGDIR.bak
        rm -rf $NETPLANDIR.bak
        mv $CFGDIR $CFGDIR.bak
        mv $NETPLANDIR $NETPLANDIR.bak
        cp -a $SVRSTATEDIR/openvpn $CFGDIR
        cp -a $SVRSTATEDIR/netplan $NETPLANDIR
        cp $SVRSTATEDIR/server.conf ${SERVERDIR}/server.conf
        if [ -d $CFGDIR -a -d $NETPLANDIR ] ; then
            netplan generate
            netplan apply
            # Restart the OpenVPN service
            systemctl restart openvpn-server@server.service
        fi
    fi
}

setup_server_snmpd () {
    local user="$1"
    local password="$2"
    shift 2

    apt install -y openssh-server snmpd snmp libsnmp-dev
    systemctl stop snmpd
    sed -i.bak 's/^sysLocation.*$/sysLocation Dali Management VPN Concentrator/;s/^sysContact.*$/sysContact Dali <support@daliwireless.com>/;s/^agentaddress.*$/agentaddress udp:161,udp6:[::1]:161/' /etc/snmp/snmpd.conf
    net-snmp-create-v3-user -ro -A "$password" -a MD5 -X "$password" -x DES "$user"
    systemctl start snmpd
}

new_client () {
    local serverip=$(get_server_ip)
    local clientip=$(get_client_ip)
    local netmask=$(ipcalc -nb ${VPNNET} | awk '/Netmask:/{print $2}')

    create_tunnel $client $clientip $serverip
    mkdir -p ${GWYSTATEDIR}/$client/etc
    # Generate netplan config for gateway
    mkdir ${GWYSTATEDIR}/$client/etc/netplan
    for template in ${TOOLDIR}/templates/client/netplan/*.tmpl ; do
        if [ -e $template ] ; then
            config=$(basename -s .tmpl $template).yaml
            (
                export CLIENTIP=$clientip
                export SERVERIP=$serverip
                cat $template | envsubst
            ) > ${GWYSTATEDIR}/$client/etc/netplan/$config
        fi
    done

    # Generates the custom client.ovpn
    {
    cat ${SERVERDIR}/client-common.txt
    echo "<ca>"
    cat ${SERVERDIR}/easy-rsa/pki/ca.crt
    echo "</ca>"
    echo "<cert>"
    sed -ne '/BEGIN CERTIFICATE/,$ p' ${SERVERDIR}/easy-rsa/pki/issued/"$client".crt
    echo "</cert>"
    echo "<key>"
    cat ${SERVERDIR}/easy-rsa/pki/private/"$client".key
    echo "</key>"
    echo "<tls-crypt>"
    sed -ne '/BEGIN OpenVPN Static key/,$ p' ${SERVERDIR}/tc.key
    echo "</tls-crypt>"
    } > ${CLIENTDIR}/"$client".ovpn
    echo "ifconfig-push ${clientip} ${netmask}" > ${CCDDIR}/"$client"

    mkdir ${GWYSTATEDIR}/$client/etc/openvpn
    cp ${CLIENTDIR}/"$client".ovpn ${GWYSTATEDIR}/$client/etc/openvpn/"$client".conf
    (
        echo '#!/bin/bash'
        echo "SNMP_USER=\"$snmp_user\""
        echo "SNMP_PASSWORD=\"$snmp_password\""
        cat ${TOOLDIR}/templates/client/selfextract_header
        tar cz -C ${GWYSTATEDIR}/$client .
    ) > ${GWYSTATEDIR}/install_$client.shar

    if [ -n "$SUDO_UID" ] ; then
        chown $SUDO_UID:$SUDO_GID ${GWYSTATEDIR}/$client
        chown $SUDO_UID:$SUDO_GID ${GWYSTATEDIR}/install_$client.shar
    fi
    chmod a+x ${GWYSTATEDIR}/install_${client}.shar

    echo "The install script for the remote gateway \"${client}\" is at:"
    echo ""
    echo "  ${GWYSTATEDIR}/install_${client}.shar"
    echo ""
    echo "Copy this file to the gateway and install it by running the command:"
    echo ""
    echo "    chmod a+x install_${client}.shar"
    echo "    sudo ./install_${client}.shar"
    echo ""
}


# MAIN starts here
# Process options

while getopts hC:c:r:s:x c ; do
    case $c in
        h) usage ; exit 0 ;;
        C) create_config "$OPTARG" ; exit 0 ;;
        c) load_config "$OPTARG" ;;
        r) opt_r="$OPTARG" ; isroot ; restore_server_config $opt_r ; exit $? ;;
        s) opt_s="$OPTARG" ; isroot ; save_server_config $opt_s ; exit $? ;;
        x) set -x ;;
        \?) usage ; >&2 echo "unknown option: $c" ; exit 1 ;;
    esac
done

isroot

if [[ ! -e ${SERVERDIR}/server.conf ]]; then
    clear
    echo 'Welcome to this Dali DMC Access Server installer!'
    echo "The network interfaces will be reconfigured first to use netplan and networkd"
    if [ -z "$wanif" -o -z "$lanifs" ] ; then
        if detect_qotom ; then
            echo "This appears to be a Qotom network applicance"
            echo "    interface 1 should be connected to the Internet/Modem"
            echo "    interfaces 3 and 4 should be connected to the DMC"
            wanif='enp1s0'
            lanifs="enp3s0 enp4s0"
        else
            select_wanif
            select_lanifs
        fi
    fi
    if [ -z "$proto" ] ; then
        wanifproto_get
        echo

        if [ $proto == 'static' ] ;then
            staticifinfo_get
        fi
    fi
    echo "Using WAN interface $wanif"
    echo "Using DMC interface(s) $lanifs"
    create_wanif $wanif
    if [ -z "$address" ] ; then
        # If system has a single IPv4, it is selected automatically. Else, ask the user
        if [[ $(ip -4 addr | grep inet | grep -vEc '127(\.[0-9]{1,3}){3}') -eq 1 ]]; then
            address=$(ip -4 addr | grep inet | grep -vE '127(\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}')
        else
            number_of_ip=$(ip -4 addr | grep inet | grep -vEc '127(\.[0-9]{1,3}){3}')
            echo
            echo "Which IPv4 address should be used?"
            ip -4 addr | grep inet | grep -vE '127(\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}' | nl -s ') '
            read -p "IPv4 address [1]: " ip_number
            until [[ -z "$ip_number" || "$ip_number" =~ ^[0-9]+$ && "$ip_number" -le "$number_of_ip" ]]; do
                echo "$ip_number: invalid selection."
                read -p "IPv4 address [1]: " ip_number
            done
            [[ -z "$ip_number" ]] && ip_number="1"
            address=$(ip -4 addr | grep inet | grep -vE '127(\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}' | sed -n "$ip_number"p)
        fi
    fi
    if [ -z "$public_address" ] ; then
        #Â If $address is a private IP address, the server must be behind NAT
        if echo "$address" | grep -qE '^(10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.|192\.168)'; then
            echo
            echo "This server is behind NAT. What is the public IPv4 address or hostname?"
            # Get public IP and sanitize with grep
            get_public_address=$(grep -m 1 -oE '^[0-9]{1,3}(\.[0-9]{1,3}){3}$' <<< "$(wget -T 10 -t 1 -4qO- "http://ip1.dynupdate.no-ip.com/" || curl -m 10 -4Ls "http://ip1.dynupdate.no-ip.com/")")
            read -p "Public IPv4 address / hostname [$get_public_address]: " public_address
            # If the checkip service is unavailable and user did not provide input, ask again
            until [[ -n "$get_public_address" || -n "$public_address" ]]; do
                echo "Invalid input."
                read -p "Public IPv4 address / hostname: " public_address
            done
            [[ -z "$public_address" ]] && public_address="$get_public_address"
        fi
    fi

    # If system has a single IPv6, it is selected automatically
    if [[ $(ip -6 addr | grep -c 'inet6 [23]') -eq 1 ]]; then
        ip6=$(ip -6 addr | grep 'inet6 [23]' | cut -d '/' -f 1 | grep -oE '([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}')
    fi
    # If system has multiple IPv6, ask the user to select one
    if [[ $(ip -6 addr | grep -c 'inet6 [23]') -gt 1 ]]; then
        number_of_ip6=$(ip -6 addr | grep -c 'inet6 [23]')
        echo
        echo "Which IPv6 address should be used?"
        ip -6 addr | grep 'inet6 [23]' | cut -d '/' -f 1 | grep -oE '([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}' | nl -s ') '
        read -p "IPv6 address [1]: " ip6_number
        until [[ -z "$ip6_number" || "$ip6_number" =~ ^[0-9]+$ && "$ip6_number" -le "$number_of_ip6" ]]; do
            echo "$ip6_number: invalid selection."
            read -p "IPv6 address [1]: " ip6_number
        done
        [[ -z "$ip6_number" ]] && ip6_number="1"
        ip6=$(ip -6 addr | grep 'inet6 [23]' | cut -d '/' -f 1 | grep -oE '([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}' | sed -n "$ip6_number"p)
    fi
    echo
    if [ -z "$protocol" -o -z "$port" ] ; then
        vpn_protocol_get
        echo
    fi
    if [ -z "$dns" ] ; then
        vpn_gateway_dns_option_get
        echo
    fi
    if [ -z "$client" ] ; then
        first_client_name_get
        echo
    fi
    if [ -z "$snmp_user" -o -z "$snmp_password" ] ; then
        snmp_user_get
        echo
    fi
    echo "DMC Access Server installation is ready to begin."
    read -n1 -r -p "Press any key to continue..."
    create_dmc_lanbr $lanifs
    # Install a firewall in the rare case where one is not already available
    if ! systemctl is-active --quiet firewalld.service && ! hash iptables 2>/dev/null; then
        if [[ "$os" == "centos" || "$os" == "fedora" ]]; then
            firewall="firewalld"
            # We do not want to silently enable firewalld, so we give a subtle warning
            # If the user continues, firewalld will be installed and enabled during setup
            echo "firewalld, which is required to manage routing tables, will also be installed."
        elif [[ "$os" == "debian" || "$os" == "ubuntu" ]]; then
            # iptables is way less invasive than firewalld so no warning is given
            firewall="iptables"
        fi
    fi
    # If running inside a container, disable LimitNPROC to prevent conflicts
    if systemd-detect-virt -cq; then
        mkdir /etc/systemd/system/openvpn-server@server.service.d/ 2>/dev/null
        echo "[Service]
LimitNPROC=infinity" > /etc/systemd/system/openvpn-server@server.service.d/disable-limitnproc.conf
    fi
    if [[ "$os" = "debian" || "$os" = "ubuntu" ]]; then
        apt-get update
        apt-get install -y curl ipcalc openvpn openssl ca-certificates $firewall
        snap install yq
    elif [[ "$os" = "centos" ]]; then
        yum install -y epel-release
        yum install -y openvpn openssl ca-certificates tar $firewall
    else
        # Else, OS must be Fedora
        dnf install -y openvpn openssl ca-certificates tar $firewall
    fi
    # If firewalld was just installed, enable it
    if [[ "$firewall" == "firewalld" ]]; then
        systemctl enable --now firewalld.service
    fi

    VPNSERVER=$(ipcalc -nb ${VPNNET} | awk '/^Address:/{printf "%s ", $2}; /^Netmask:/{print $2}')

    # Get easy-rsa
    easy_rsa_url='https://github.com/OpenVPN/easy-rsa/releases/download/v3.0.8/EasyRSA-3.0.8.tgz'
    mkdir -p ${SERVERDIR}/easy-rsa/
    { wget -qO- "$easy_rsa_url" 2>/dev/null || curl -sL "$easy_rsa_url" ; } | tar xz -C ${SERVERDIR}/easy-rsa/ --strip-components 1
    chown -R root:root ${SERVERDIR}/easy-rsa/
    cd ${SERVERDIR}/easy-rsa/
    # Create the PKI, set up the CA and the server and client certificates
    ./easyrsa init-pki
    ./easyrsa --batch build-ca nopass
    EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-server-full server nopass
    EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-client-full "$client" nopass
    EASYRSA_CRL_DAYS=3650 ./easyrsa gen-crl
    # Move the stuff we need
    cp pki/ca.crt pki/private/ca.key pki/issued/server.crt pki/private/server.key pki/crl.pem ${SERVERDIR}
    # CRL is read with each client connection, while OpenVPN is dropped to nobody
    chown nobody:"$group_name" ${SERVERDIR}/crl.pem
    # Without +x in the directory, OpenVPN can not run a stat() on the CRL file
    chmod o+x ${SERVERDIR}/
    # Generate key for tls-crypt
    openvpn --genkey --secret ${SERVERDIR}/tc.key
    # Create the DH parameters file using the predefined ffdhe2048 group
    echo '-----BEGIN DH PARAMETERS-----
MIIBCAKCAQEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz
+8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a
87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7
YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi
7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaD
ssbzSibBsu/6iGtCOGEoXJf//////////wIBAg==
-----END DH PARAMETERS-----' > ${SERVERDIR}/dh.pem
    # Generate server.conf
    echo "local $address
port $port
proto $protocol
dev tun
ca ca.crt
cert server.crt
key server.key
dh dh.pem
auth SHA512
tls-crypt tc.key
topology subnet
server ${VPNSERVER}" > ${SERVERDIR}/server.conf
    # IPv6
    if [[ -z "$ip6" ]]; then
        echo 'push "redirect-gateway def1 bypass-dhcp"' >> ${SERVERDIR}/server.conf
    else
        echo 'server-ipv6 fddd:1194:1194:1194::/64' >> ${SERVERDIR}/server.conf
        echo 'push "redirect-gateway def1 ipv6 bypass-dhcp"' >> ${SERVERDIR}/server.conf
    fi
    echo "client-config-dir ${CCDDIR}" >> ${SERVERDIR}/server.conf
    mkdir -p ${CCDDIR}
    # DNS
    case "$dns" in
        1|"")
            # Locate the proper resolv.conf
            # Needed for systems running systemd-resolved
            if grep -q '^nameserver 127.0.0.53' "/etc/resolv.conf"; then
                resolv_conf="/run/systemd/resolve/resolv.conf"
            else
                resolv_conf="/etc/resolv.conf"
            fi
            # Obtain the resolvers from resolv.conf and use them for OpenVPN
            grep -v '^#\|^;' "$resolv_conf" | grep '^nameserver' | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}' | while read line; do
                echo "push \"dhcp-option DNS $line\"" >> ${SERVERDIR}/server.conf
            done
        ;;
        2)
            echo 'push "dhcp-option DNS 8.8.8.8"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 8.8.4.4"' >> ${SERVERDIR}/server.conf
        ;;
        3)
            echo 'push "dhcp-option DNS 1.1.1.1"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 1.0.0.1"' >> ${SERVERDIR}/server.conf
        ;;
        4)
            echo 'push "dhcp-option DNS 208.67.222.222"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 208.67.220.220"' >> ${SERVERDIR}/server.conf
        ;;
        5)
            echo 'push "dhcp-option DNS 9.9.9.9"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 149.112.112.112"' >> ${SERVERDIR}/server.conf
        ;;
        6)
            echo 'push "dhcp-option DNS 94.140.14.14"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 94.140.15.15"' >> ${SERVERDIR}/server.conf
        ;;
    esac
    echo "keepalive 10 120
cipher AES-256-CBC
user nobody
group $group_name
log /var/log/openvpn/openvpn.log
persist-key
persist-tun
verb 3
compress lz4-v2
push \"compress lz4-v2\"
crl-verify crl.pem" >> ${SERVERDIR}/server.conf
    if [[ "$protocol" = "udp" ]]; then
        echo "explicit-exit-notify" >> ${SERVERDIR}/server.conf
    fi
    # Enable net.ipv4.ip_forward for the system
    echo 'net.ipv4.ip_forward=1' > /etc/sysctl.d/30-openvpn-forward.conf
    # Enable without waiting for a reboot or service restart
    echo 1 > /proc/sys/net/ipv4/ip_forward
    if [[ -n "$ip6" ]]; then
        # Enable net.ipv6.conf.all.forwarding for the system
        echo "net.ipv6.conf.all.forwarding=1" >> /etc/sysctl.d/30-openvpn-forward.conf
        # Enable without waiting for a reboot or service restart
        echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
    fi
    if systemctl is-active --quiet firewalld.service; then
        # Using both permanent and not permanent rules to avoid a firewalld
        # reload.
        # We do not use --add-service=openvpn because that would only work with
        # the default port and protocol.
        firewall-cmd --add-port="$port"/"$protocol"
        firewall-cmd --zone=trusted --add-source=${VPNNET}
        firewall-cmd --permanent --add-port="$port"/"$protocol"
        firewall-cmd --permanent --zone=trusted --add-source=${VPNNET}
        # Set NAT for the VPN subnet
        firewall-cmd --direct --add-rule ipv4 nat POSTROUTING 0 -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to "$address"
        firewall-cmd --permanent --direct --add-rule ipv4 nat POSTROUTING 0 -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to "$address"
        if [[ -n "$ip6" ]]; then
            firewall-cmd --zone=trusted --add-source=fddd:1194:1194:1194::/64
            firewall-cmd --permanent --zone=trusted --add-source=fddd:1194:1194:1194::/64
            firewall-cmd --direct --add-rule ipv6 nat POSTROUTING 0 -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to "$ip6"
            firewall-cmd --permanent --direct --add-rule ipv6 nat POSTROUTING 0 -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to "$ip6"
        fi
    else
        # Create a service to set up persistent iptables rules
        iptables_path=$(command -v iptables)
        ip6tables_path=$(command -v ip6tables)
        # nf_tables is not available as standard in OVZ kernels. So use iptables-legacy
        # if we are in OVZ, with a nf_tables backend and iptables-legacy is available.
        if [[ $(systemd-detect-virt) == "openvz" ]] && readlink -f "$(command -v iptables)" | grep -q "nft" && hash iptables-legacy 2>/dev/null; then
            iptables_path=$(command -v iptables-legacy)
            ip6tables_path=$(command -v ip6tables-legacy)
        fi
        echo "[Unit]
Before=network.target
[Service]
Type=oneshot
ExecStart=$iptables_path -t nat -A POSTROUTING -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to $address
ExecStart=$iptables_path -I INPUT -p $protocol --dport $port -j ACCEPT
ExecStart=$iptables_path -I FORWARD -s ${VPNNET} -j ACCEPT
ExecStart=$iptables_path -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
ExecStop=$iptables_path -t nat -D POSTROUTING -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to $address
ExecStop=$iptables_path -D INPUT -p $protocol --dport $port -j ACCEPT
ExecStop=$iptables_path -D FORWARD -s ${VPNNET} -j ACCEPT
ExecStop=$iptables_path -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT" > /etc/systemd/system/openvpn-iptables.service
        if [[ -n "$ip6" ]]; then
            echo "ExecStart=$ip6tables_path -t nat -A POSTROUTING -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to $ip6
ExecStart=$ip6tables_path -I FORWARD -s fddd:1194:1194:1194::/64 -j ACCEPT
ExecStart=$ip6tables_path -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
ExecStop=$ip6tables_path -t nat -D POSTROUTING -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to $ip6
ExecStop=$ip6tables_path -D FORWARD -s fddd:1194:1194:1194::/64 -j ACCEPT
ExecStop=$ip6tables_path -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT" >> /etc/systemd/system/openvpn-iptables.service
        fi
        echo "RemainAfterExit=yes
[Install]
WantedBy=multi-user.target" >> /etc/systemd/system/openvpn-iptables.service
        systemctl enable --now openvpn-iptables.service
    fi
    # If SELinux is enabled and a custom port was selected, we need this
    if sestatus 2>/dev/null | grep "Current mode" | grep -q "enforcing" && [[ "$port" != 1194 ]]; then
        # Install semanage if not already present
        if ! hash semanage 2>/dev/null; then
            if [[ "$os_version" -eq 7 ]]; then
                # Centos 7
                yum install -y policycoreutils-python
            else
                # CentOS 8 or Fedora
                dnf install -y policycoreutils-python-utils
            fi
        fi
        semanage port -a -t openvpn_port_t -p "$protocol" "$port"
    fi
    # If the server is behind NAT, use the correct IP address
    [[ -n "$public_address" ]] && address="$public_address"
    # client-common.txt is created so we have a template to add further users later
    echo "client
dev tun
proto $protocol
remote $address $port
resolv-retry infinite
nobind
persist-key
persist-tun
remote-cert-tls server
auth SHA512
cipher AES-256-CBC
ignore-unknown-option block-outside-dns
block-outside-dns
comp-lzo
verb 3" > ${SERVERDIR}/client-common.txt
    # Enable and start the OpenVPN service
    systemctl enable --now openvpn-server@server.service
    if [ ! -f $STATEDIR/.snmpauth ] ; then
        # Setup SNMP monitoring
        setup_server_snmpd "$snmp_user" "$snmp_password"
        echo "snmp_user=\"$snmp_user\"" > $STATEDIR/.snmpauth
        echo "snmp_password=\"$snmp_password\"" >> $STATEDIR/.snmpauth
    fi
    # Generates the custom client.ovpn
    new_client
    echo
    echo "Finished!"
    echo
    echo "New clients can be added by running this script again."
else
    clear
    echo "DMC Access Server is already installed."
    echo
    echo "Select an option:"
    echo "   1) Add a new remote gateway"
    echo "   2) Revoke an existing remote gateway"
    echo "   3) Remove DMC Access Server"
    echo "   4) Exit"
    read -p "Option: " option
    until [[ "$option" =~ ^[1-4]$ ]]; do
        echo "$option: invalid selection."
        read -p "Option: " option
    done
    case "$option" in
        1)
            echo
            echo "Provide a name for the gateway:"
            read -p "Name: " unsanitized_client
            client=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_client")
            while [[ -z "$client" || -e ${SERVERDIR}/easy-rsa/pki/issued/"$client".crt ]]; do
                echo "$client: invalid name."
                read -p "Name: " unsanitized_client
                client=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_client")
            done
            cd ${SERVERDIR}/easy-rsa/
            EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-client-full "$client" nopass
            # Generates the custom client.ovpn
            new_client
            exit
        ;;
        2)
            # This option could be documented a bit better and maybe even be simplified
            # ...but what can I say, I want some sleep too
            number_of_clients=$(tail -n +2 ${SERVERDIR}/easy-rsa/pki/index.txt | grep -c "^V")
            if [[ "$number_of_clients" = 0 ]]; then
                echo
                echo "There are no existing gateways!"
                exit
            fi
            echo
            echo "Select the gateway to revoke:"
            tail -n +2 ${SERVERDIR}/easy-rsa/pki/index.txt | grep "^V" | cut -d '=' -f 2 | nl -s ') '
            read -p "Gateway: " client_number
            until [[ "$client_number" =~ ^[0-9]+$ && "$client_number" -le "$number_of_clients" ]]; do
                echo "$client_number: invalid selection."
                read -p "Gateway: " client_number
            done
            client=$(tail -n +2 ${SERVERDIR}/easy-rsa/pki/index.txt | grep "^V" | cut -d '=' -f 2 | sed -n "$client_number"p)
            echo
            read -p "Confirm $client revocation? [y/N]: " revoke
            until [[ "$revoke" =~ ^[yYnN]*$ ]]; do
                echo "$revoke: invalid selection."
                read -p "Confirm $client revocation? [y/N]: " revoke
            done
            if [[ "$revoke" =~ ^[yY]$ ]]; then
                cd ${SERVERDIR}/easy-rsa/
                ./easyrsa --batch revoke "$client"
                EASYRSA_CRL_DAYS=3650 ./easyrsa gen-crl
                rm -f ${SERVERDIR}/crl.pem
                cp ${SERVERDIR}/easy-rsa/pki/crl.pem ${SERVERDIR}/crl.pem
                # CRL is read with each client connection, when OpenVPN is dropped to nobody
                chown nobody:"$group_name" ${SERVERDIR}/crl.pem
                echo
                destroy_tunnel $client
                echo "$client revoked!"
            else
                echo
                echo "$client revocation aborted!"
            fi
            exit
        ;;
        3)
            echo
            read -p "Confirm DMC Access Server removal? [y/N]: " remove
            until [[ "$remove" =~ ^[yYnN]*$ ]]; do
                echo "$remove: invalid selection."
                read -p "Confirm DMC Access Server removal? [y/N]: " remove
            done
            if [[ "$remove" =~ ^[yY]$ ]]; then
                port=$(grep '^port ' ${SERVERDIR}/server.conf | cut -d " " -f 2)
                protocol=$(grep '^proto ' ${SERVERDIR}/server.conf | cut -d " " -f 2)
                if systemctl is-active --quiet firewalld.service; then
                    address=$(firewall-cmd --direct --get-rules ipv4 nat POSTROUTING | grep "\-s ${VPNNET} ""'"'!'"'"" -d ${VPNNET}" | grep -oE '[^ ]+$')
                    # Using both permanent and not permanent rules to avoid a firewalld reload.
                    firewall-cmd --remove-port="$port"/"$protocol"
                    firewall-cmd --zone=trusted --remove-source=${VPNNET}
                    firewall-cmd --permanent --remove-port="$port"/"$protocol"
                    firewall-cmd --permanent --zone=trusted --remove-source=${VPNNET}
                    firewall-cmd --direct --remove-rule ipv4 nat POSTROUTING 0 -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to "$address"
                    firewall-cmd --permanent --direct --remove-rule ipv4 nat POSTROUTING 0 -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to "$address"
                    if grep -qs "server-ipv6" ${SERVERDIR}/server.conf; then
                        ip6=$(firewall-cmd --direct --get-rules ipv6 nat POSTROUTING | grep '\-s fddd:1194:1194:1194::/64 '"'"'!'"'"' -d fddd:1194:1194:1194::/64' | grep -oE '[^ ]+$')
                        firewall-cmd --zone=trusted --remove-source=fddd:1194:1194:1194::/64
                        firewall-cmd --permanent --zone=trusted --remove-source=fddd:1194:1194:1194::/64
                        firewall-cmd --direct --remove-rule ipv6 nat POSTROUTING 0 -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to "$ip6"
                        firewall-cmd --permanent --direct --remove-rule ipv6 nat POSTROUTING 0 -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to "$ip6"
                    fi
                else
                    systemctl disable --now openvpn-iptables.service
                    rm -f /etc/systemd/system/openvpn-iptables.service
                fi
                if sestatus 2>/dev/null | grep "Current mode" | grep -q "enforcing" && [[ "$port" != 1194 ]]; then
                    semanage port -d -t openvpn_port_t -p "$protocol" "$port"
                fi
                systemctl disable --now openvpn-server@server.service
                rm -rf ${SERVERDIR}
                rm -f /etc/systemd/system/openvpn-server@server.service.d/disable-limitnproc.conf
                rm -f /etc/sysctl.d/30-openvpn-forward.conf
                restore_networking_default
                if [[ "$os" = "debian" || "$os" = "ubuntu" ]]; then
                    apt-get remove --purge -y openvpn
                else
                    # Else, OS must be CentOS or Fedora
                    yum remove -y openvpn
                fi
                echo
                echo "DMC Access Server removed!"
            else
                echo
                echo "DMC Access Server removal aborted!"
            fi
            exit
        ;;
        4)
            exit
        ;;
    esac
fi

