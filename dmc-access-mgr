#!/bin/bash
#
# Copyright Dali Wireless 2021
#
# Based on the work:
#
# https://github.com/Nyr/openvpn-install
#
# Copyright (c) 2013 Nyr. Released under the MIT License.
shopt -s extglob
VPNNET=10.8.0.0/24
CFGDIR=/etc/openvpn
CCDDIR=${CFGDIR}/ccd
CLIENTDIR=${CFGDIR}/client
SERVERDIR=${CFGDIR}/server
TOOLDIR=$(cd $(dirname $0) && pwd)
STATEDIR=$TOOLDIR/state
GWYSTATEDIR=$STATEDIR/gateways
SVRSTATEDIR=$STATEDIR/server
: ${NETPLANDIR:=/etc/netplan}
progname=$(basename $0)
activate_wanif='yes'

opt_s=''
opt_r=''

usage() {
    cat << _EOF

"$progname" manage the DMC VPN server and remote gateways

Usage: sudo $0 [OPTIONS]
       $0 -h

When run without options $progname runs in an interactive mode. The use
of "sudo" is required for all actions except the help and create
configuration modes.

If this system is not installed in its final production location, use a
configuration  file to specify the parameters of the final installation.
A configuration file is created with the '-C' option. Then copy the config
file to the production system and activate with the '-c' option.

The first time it is run, the OVPN server, SNMP server, SSH server and the
network topology will be initialized and a first gateway config created.

Subsequent runs with no options can be used to add gateways and to revoke
gateways.

The following options can be used to mirror the configuration to a cold standby
DMC access server. The active server should be saved after any changes to the
remote gateway configuration, then restored on the standby side.

NOTE: On the standby side, a saved configuration should be restored  after
$progname has been run once. This will overwrite the initial gateway created in
the setup process on the standby side, and will render the standby a clone of the
active DMC access server. The initial setup is required to ensure the necessary
software packages are installed.

OPTIONS:

 -h               This help screen (does not require sudo)
 -C  [CFGFILE]    Create a new configuration file and exits
 -c  [CFGFILE]    Apply a previously created configuration file
 -D               Download all the software required now. This allows the server
                  to be configured later when no Internet access is available.
 -r  [TARFILE]    Restore DMC access server config from the TARFILE.
 -R               Recover the VPN server from a backup. The backup has alreasy
                  been extracted in the current directory. This is used to initialize
                  a spare replacement server to replace a failed DMC access server.
 -s  [IP|TARFILE] Save server config directly to IP address, or save to TARFILE
                  for manual transfer to standby system.
 -x               Turn on bash shell tracing.

_EOF
}

[ -d $STATEDIR ] || mkdir $STATEDIR
[ -f $STATEDIR/.snmpauth ] && . $STATEDIR/.snmpauth

# Detect Debian users running the script with "sh" instead of bash
if readlink /proc/$$/exe | grep -q "dash"; then
    echo 'This installer needs to be run with "bash", not "sh".'
    exit
fi

# Discard stdin. Needed when running from an one-liner which includes a newline
read -N 999999 -t 0.001

# Detect OpenVZ 6
if [[ $(uname -r | cut -d "." -f 1) -eq 2 ]]; then
    echo "The system is running an old kernel, which is incompatible with this installer."
    exit
fi

# Detect OS
# $os_version variables aren't always in use, but are kept here for convenience
if grep -qs "alpine" /etc/os-release; then
    os="alpine"
    os_version=$(grep 'VERSION_ID' /etc/os-release | cut -d '"' -f 2 | tr -d '.')
    group_name="nogroup"
elif grep -qs "ubuntu" /etc/os-release; then
    os="ubuntu"
    os_version=$(grep 'VERSION_ID' /etc/os-release | cut -d '"' -f 2 | tr -d '.')
    group_name="nogroup"
elif [[ -e /etc/debian_version ]]; then
    os="debian"
    os_version=$(grep -oE '[0-9]+' /etc/debian_version | head -1)
    group_name="nogroup"
elif [[ -e /etc/centos-release ]]; then
    os="centos"
    os_version=$(grep -oE '[0-9]+' /etc/centos-release | head -1)
    group_name="nobody"
elif [[ -e /etc/fedora-release ]]; then
    os="fedora"
    os_version=$(grep -oE '[0-9]+' /etc/fedora-release | head -1)
    group_name="nobody"
else
    echo "This installer seems to be running on an unsupported distribution.
Supported distributions are Ubuntu, Debian, CentOS, and Fedora."
    exit
fi

if [[ "$os" == "ubuntu" && "$os_version" -lt 1804 ]]; then
    echo "Ubuntu 18.04 or higher is required to use this installer.
This version of Ubuntu is too old and unsupported."
    exit
fi

if [[ "$os" == "debian" && "$os_version" -lt 9 ]]; then
    echo "Debian 9 or higher is required to use this installer.
This version of Debian is too old and unsupported."
    exit
fi

if [[ "$os" == "centos" && "$os_version" -lt 7 ]]; then
    echo "CentOS 7 or higher is required to use this installer.
This version of CentOS is too old and unsupported."
    exit
fi

# Detect environments where $PATH does not include the sbin directories
if ! grep -q sbin <<< "$PATH"; then
    echo '$PATH does not include sbin. Try using "su -" instead of "su".'
    exit
fi

if [[ ! -e /dev/net/tun ]] || ! ( exec 7<>/dev/net/tun ) 2>/dev/null; then
    echo "The system does not have the TUN device available.
TUN needs to be enabled before running this installer."
    exit
fi

isroot() {
    if [[ "$EUID" -ne 0 ]]; then
        echo "This installer needs to be run with superuser privileges."
        exit
    fi
}

ip2dec() {
    declare -i a b c d
    IFS=. read a b c d <<<"$1"
    echo "$(((10#$a<<24)+(10#$b<<16)+(10#$c<<8)+10#$d))"
}

dec2ip() {
    local ip=$1
    local i s
    for i in {1..4}; do
        s='.'$((ip%256))$s && ((ip>>=8))
    done
    echo ${s:1}
}

ipv4address_get() {
    local prompt=$1
    local address=""
    while : ; do
        read -p "$prompt (N.N.N.N, N is 0-255) " address
        case $address in
            "") break ;;
            +([0-9]).+([0-9]).+([0-9]).+([0-9]))
                o1=${address%%.*}
                octets=${address#*.}
                o2=${octets%%.*}
                octets=${octets#*.}
                o3=${octets%%.*}
                o4=${octets##*.}

                for octet in "$o1" "$o2" "$o3" "$o4" ; do
                    if [ $octet -gt 255 ] ; then
                        >&2 echo "$address is invalid, the part $octet must be less than 255"
                        address=''
                        break
                    fi
                done

                if [ -n "$address" ] ; then
                    read -p "The provided internet address is [$address] ? [Yn] " reply
                    case $reply in
                        [Yy]*) ;;
                        '') ;;
                        *) address='' ;;
                    esac
                fi
                ;;
            *) >&2 echo "Did not recognize address format, Should be N.N.N.N format" ; echo ; address='' ;;
        esac
        if [ -n "$address" ] ; then
            break
        fi
    done
    echo "$address"
}

#
# Select the interface configuration method
# The following variable is set on return:
# - proto
#
ifproto_get() {
    declare -n _proto="$1"
    _proto=""
    while : ; do
        read -p "Will the WAN interface be manually or automatically configured? (static|dhcp) " _proto
        case $_proto in
            "") ;;
            static) read -p "The WAN interface configuration will be manual? [Yn] " reply
                case $reply in
                    [Yy]*) ;;
                    '') ;;
                    *) _proto="" ;;
                esac
                ;;
            dhcp) read -p "The WAN interface configuration will be automatic? [Yn] " reply
                case $reply in
                    [Yy]*) ;;
                    '') ;;
                    *) _proto="" ;;
                esac
                ;;
        esac
        if [ -n "$_proto" ] ; then
            break
        fi
    done
}

#
# @param $1 - a bash array
# This method sets the following keys
# on return.
# - address (IPv4 address)
# - netmask (as bit count)
# - gateway (IPv4 address)
# - nameservers (comma seperated list of IPv4 addresses)
#
ifinfo_get() {
    declare -n ifinfo="$1"
    local reply=''
    local address=""
    while : ; do
        address=$(ipv4address_get "What is the IPv4 address of the WAN interface?")
        if [ -n "$address" ] ; then
            break
        else
            echo "The WAN interface address must be provided when using manual interface configuration"
        fi
    done
    echo

    local netmask=""
    while : ; do
        read -p "Enter the number of bits in the netmask? [8-30] " netmask
        case $netmask in
            "") echo "The WAN interface netmask must be provided when using manual interface configuration" ; echo ; netmask='' ;;
            8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30) read -p "The WAN interface netmask is [$netmask] bits? [Yn] " reply
                case $reply in
                    [Yy]*) ;;
                    '') ;;
                    *) netmask='' ;;
                esac
                ;;
            *) echo 'The number of bits is invalid, provide a number between 8 and 30 inclusive' ; echo ; netmask='' ;;
        esac
        if [ -n "$netmask" ] ; then
            break
        fi
    done
    echo

    local gateway=""
    while : ; do
        gateway=$(ipv4address_get "What is the IPv4 address of the WAN gateway?")
        if [ -n "$gateway" ] ; then
            break
        else
            echo "The WAN gateway address must be provided when using manual interface configuration"
        fi
    done
    echo

    local nameservers=""
    local nameserver=''
    while : ; do
        nameserver=$(ipv4address_get "What is the IPv4 address of the WAN name server?")
        local prompt=''
        local yAction=''
        local nAction=''
        local defaultAction=''
        if [ -z "$nameserver" -a -z "$nameservers" ] ; then
            prompt='No nameservers will be provisioned on this interface? [Yn] '
            yAction='break'
            nAction=''
            defaultAction='break'
        elif [ -n "$nameserver" -a -z "$nameservers" ] ; then
            nameservers="$nameserver"
            prompt="Add another nameserver [$nameservers] ? [yN] "
            yAction=''
            nAction='breck'
            defaultAction='break'
        elif [ -n "$nameserver" -a -n "$nameservers" ] ; then
            nameservers="$nameservers,$nameserver"
            prompt="Add another nameserver [$nameservers] ? [yN] "
            yAction=''
            nAction='breck'
            defaultAction='break'
        else
            prompt="Add another nameserver [$nameservers] ? [yN] "
            yAction=''
            nAction='breck'
            defaultAction='break'
        fi
        read -p "$prompt" reply
        case $reply in
            [Yy]*) [ "$yAction" == 'break' ] && break ;;
            '') [ "$defaultAction" == 'break' ] && break ;;
            *) [ "$nAction" == 'break' ] && break ;;
        esac
    done
    echo

    ifinfo['address']=$address
    ifinfo['netmask']=$netmask
    ifinfo['gateway']=$gateway
    ifinfo['nameservers']="$nameservers"
}

#
# This method sets the following variables
# on return.
# - address (IPv4 address)
# - netmask (as bit count)
# - gateway (IPv4 address)
# - nameservers (comma seperated list of IPv4 addresses)
# - activate_wanif (yes|no)
#
staticifinfo_get() {
    declare -A params
    ifinfo_get params

    address=${params['address']}
    netmask=${params['netmask']}
    gateway=${params['gateway']}
    nameservers=${params['nameservers']}

    local reply=''
    activate_wanif=""
    while : ; do
        read -p "Activate the WAN interface before configuring? [Yn] " activate_wanif
        case $activate_wanif in
            "") activate_wanif='yes' ;;
            y*|Y*) activate_wanif='yes' ;;
            n*|N*) activate_wanif='no' ;;
            *) echo 'The answer is yes or no' ; echo ; activate_wanif='' ;;
        esac
        if [ -n "$activate_wanif" ] ; then
            break
        fi
    done
    echo
}

#
# Get the VPN transport protocol and port
# on return the following variables are set
# - protocol (tcp|udp)
# - port
#
vpn_protocol_get() {
    echo "Which protocol should DMC Access Server use?"
    echo "   1) UDP (recommended)"
    echo "   2) TCP"
    read -p "Protocol [1]: " protocol
    until [[ -z "$protocol" || "$protocol" =~ ^[12]$ ]]; do
        echo "$protocol: invalid selection."
        read -p "Protocol [1]: " protocol
    done
    case "$protocol" in
        1|"") 
        protocol=udp
        ;;
        2) 
        protocol=tcp
        ;;
    esac
    echo
    echo "What port should DMC Access Server listen to?"
    read -p "Port [1194]: " port
    until [[ -z "$port" || "$port" =~ ^[0-9]+$ && "$port" -le 65535 ]]; do
        echo "$port: invalid port."
        read -p "Port [1194]: " port
    done
    [[ -z "$port" ]] && port="1194"
}

#
# Get the DNS server option to be used by the gateway
# On return the following variable is set:
# - dns (the gateway DNS option)
#    1) Current system resolvers
#    2) Google
#    3) 1.1.1.1
#    4) OpenDNS
#    5) Quad9
#    6) AdGuard
#
vpn_gateway_dns_option_get() {
    echo "Select a DNS server for the gateways:"
    echo "   1) Current system resolvers"
    echo "   2) Google"
    echo "   3) 1.1.1.1"
    echo "   4) OpenDNS"
    echo "   5) Quad9"
    echo "   6) AdGuard"
    read -p "DNS server [1]: " dns
    until [[ -z "$dns" || "$dns" =~ ^[1-6]$ ]]; do
        echo "$dns: invalid selection."
        read -p "DNS server [1]: " dns
    done
    [[ -z "$dns" ]] && dns=1
}

#
# Get the first client name to be created on install
# On return the following variable is set:
# - client (name of first gatway)
#
first_client_name_get() {
    echo "Enter a name for the first gateway:"
    read -p "Name [gateway]: " unsanitized_client
    # Allow a limited set of characters to avoid conflicts
    client=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_client")
    [[ -z "$client" ]] && client="gateway"
}

client_config() {
    echo "The VPN gateway can be configured to use DHCP, or use a static IP configuration."
    echo "If a static configuration is selected, then all gateways must use the same static"
    echo "configuration. This means remote modems must be configured to use the gateway"
    echo "address provided as the LAN IP address with the same netmask."
    echo
    echo "A mixture of static and DHCP, or a mixture of static addresses are not supported."
    echo

    first_client_name_get
    cproto=''
    ifproto_get cproto
    mkdir -p $GWYSTATEDIR
    echo "CLIENT_PROTO=$cproto" > $STATEDIR/.gwconfig
    if [ $cproto == 'static' ] ; then
        declare -A cparams
        ifinfo_get cparams
        echo "CLIENT_ADDRESS=${cparams['address']}" >> $STATEDIR/.gwconfig
        echo "CLIENT_NETMASK=${cparams['netmask']}" >> $STATEDIR/.gwconfig
        echo "CLIENT_GATEWAY=${cparams['gateway']}" >> $STATEDIR/.gwconfig
        echo "CLIENT_NAMESERVERS=${cparams['nameservers']}" >> $STATEDIR/.gwconfig
    fi
}

#
# Get the user and password for SNMPv3 authentication
# On return the following variables are set
# - snmp_user (the SNMPv3 user name)
# - snmp_password (the SNMPv3 user password)
#
snmp_user_get() {
    echo "Enter a user name for SNMPv3 monitoring:"
    read -p "SNMP user name [dali]: " unsanitized_snmp_user
    # Allow a limited set of characters to avoid conflicts
    snmp_user=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_snmp_user")
    [[ -z "$snmp_user" ]] && snmp_user="dali"
    echo "Using SNMP user name \"$snmp_user\" (on both server and gateways for both authentication and privacy)"
    echo
    echo "Enter a password for SNMPv3 monitoring:"
    read -p "SNMP password [dali1234]: " unsanitized_snmp_password
    # Allow a limited set of characters to avoid conflicts
    snmp_password=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_snmp_password")
    [[ -z "$snmp_password" ]] && snmp_password="dali1234"
    echo "Using SNMP password \"$snmp_password\" (on both server and gateways for both authentication and privacy)"
}

create_config() {
    local cfgfile=$1

    local qotom=""
    local wanif="enp1s0"
    local mgmtif="enp2s0"
    local lanifs="enp3s0,enp4s0"
    echo
    while : ; do
        read -p "Is the target hardware a QOTOM Q190G4N? " qotom
        case $qotom in
            "") ;;
            [yY]*)
                qotom='yes'
                echo "Setting interface names for QOTOM Q190G4N"
                ;;
            *)
                qotom='no'
                echo "Interface names will need to be manually provided"
                ;;
        esac
        if [ -n "$qotom" ] ; then
            break
        fi
    done
    echo

    if [ $qotom == 'no' ] ; then
        wanif=""
        while : ; do
            read -p "Which interface is connected to the Internet? " wanif
            case $wanif in
                "") ;;
                *)
                    read -p "The internet facing interface will be named [$wanif]? [Yn] " reply
                    case $reply in
                        [Yy]*) ;;
                        '') ;;
                        *) wanif="" ;;
                    esac
                    ;;
            esac
            if [ -n "$wanif" ] ; then
                break
            fi
        done
        echo

        mgmtif=""
        while : ; do
            read -p "Which interface will be reserved for management? (enter 'none' for no management interface) " mgmtif
            case $mgmtif in
                "") ;;
                none)
                    read -p "There will be no management interface? [Yn] " reply
                    case $reply in
                        [Yy]*) ;;
                        '') ;;
                        *) mgmtif="" ;;
                    esac
                    ;;
                *)
                    read -p "The management interface will be named [$mgmtif]? [Yn] " reply
                    case $reply in
                        [Yy]*) ;;
                        '') ;;
                        *) mgmtif="" ;;
                    esac
                    ;;
            esac
            if [ -n "$mgmtif" ] ; then
                break
            fi
        done
        echo

        lanifs=""
        while : ; do
            read -p "Which interface(s) are connected to the DMC(s)? (comma seperate multiple interface names, no spaces) " lanifs
            case $lanifs in
                "") ;;
                *,*) read -p "The DMC facing interfaces are named [$lanifs]? [Yn] " reply
                    case $reply in
                        [Yy]*) ;;
                        '') ;;
                        *) lanifs="" ;;
                    esac
                    ;;
                *) read -p "The DMC facing interface is named [$lanifs]? [Yn] " reply
                    case $reply in
                        [Yy]*) ;;
                        '') ;;
                        *) lanifs="" ;;
                    esac
                    ;;
            esac
            if [ -n "$lanifs" ] ; then
                break
            fi
        done
        echo
    fi

    ifproto_get proto
    echo

    if [ $proto == 'static' ] ;then
        if [ "$mgmtif" == 'none' ] ; then
            >&2 echo "error: a management interface has to be defined when using a static WAN configuration"
            exit 1
        fi
        staticifinfo_get
    fi

    local public_address=""
    while : ; do
        public_address=$(ipv4address_get "What is the public IPv4 address of the VPN server?")
        if [ -n "$public_address" ] ; then
            break
        fi
    done

    vpn_protocol_get
    echo

    vpn_gateway_dns_option_get
    echo

    client_config
    echo

    snmp_user_get
    echo

    write_config_file $cfgfile
}

write_config_file() {
    local cfgfile=$1

    cat << __EOF > $cfgfile
# Run ./dmc-access-server -C to create a new
# configuration file.

# WANIF
# the interface name of the WAN interface

WANIF=$wanif

# MGMTIF
# the interface name of the management interface
# The management interface runs DHCPv4, but ignores
# any routing info provided by DHCP. Plugging a
# management machine running a DHCP server will
# allow this intercae to come up and SSH access
# is allowed.
#
# Set to 'none' to disable this feature

MGMTIF=$mgmtif

# LANIFS
# a list of comma delimited interface names on the LAN side
# All these interfaces will be joined into a bridge and can
# be used to connect to individual DMC's or multiple links
# to a single DMC

LANIFS=$lanifs

#
# PROTO
# Set static for statically configured WAN interface
# Set dhcp for dynamically configured WAN interface
#
PROTO=$proto

#
# * ADDRESS - static IPv4 address of the WAN interface
# * NETMASK - netmask of the network connected to the WAN interface
# * GATEWAY - IP address of default gateway on the WAN interface
# * NAMESERVERS - IP address of the DNS servers, a comma seperated list
#
# If PROTO is static the following parameters are required:
# If PROTO is dynamic and the above parameters are set, the automatic
# detection features of this script are disabled and the manually
# configured values are used.

ADDRESS=$address
NETMASK=$netmask
GATEWAY=$gateway
NAMESERVERS=$nameservers

#
# ACTIVATE_WANIF
# Activate the WAN interface prior to proceeding with
# configuration. If the WAN is using a static configuration
# and the machine is not coonnected to its final production
# network, set this option to 'no'

ACTIVATE_WANIF=$activate_wanif

#
# PUBLIC_ADDRESS
# The public IP address can be automatically determined if the server
# is connected to the network and the Internet is accessible. Otherwise
# the public IP address can be configured. Configuring a public IP
# address disables the automatic detection.

PUBLIC_ADDRESS=$public_address

#
# PROTOCOL
# The VPN transport protocol, either tcp or udp

PROTOCOL=$protocol

#
# PORT
# The VPN server port number

PORT=$port

#
# DNS
# The gateway DNS option
#    1) Current system resolvers
#    2) Google
#    3) 1.1.1.1
#    4) OpenDNS
#    5) Quad9
#    6) AdGuard

DNS=$dns

#
# CLIENT
# The name of the first client gateway to be created
# and the client WAN interface config

CLIENT=$client
$(cat $STATEDIR/.gwconfig)

#
# SNMP_USER
# The user name to use for SNMPv3 authentication

SNMP_USER=$snmp_user

#
# SNMP_PASSWORD
# The user password to use for SNMPv3 authentication

SNMP_PASSWORD=$snmp_password
__EOF
}

load_config() {
    local cfgfile=$1
    if [ -f "$cfgfile" ] ; then
        . "$cfgfile"
        wanif=$WANIF
        mgmtif=$MGMTIF
        lanifs=$LANIFS
        proto=$PROTO
        address=$ADDRESS
        netmask=$NETMASK
        gateway=$GATEWAY
        nameservers=$NAMESERVERS
        activate_wanif=$ACTIVATE_WANIF
        public_address=$PUBLIC_ADDRESS
        protocol=$PROTOCOL
        port=$PORT
        dns=$DNS
        client=$CLIENT
        mkdir -p $GWYSTATEDIR
        echo "CLIENT_PROTO=$CLIENT_PROTO" > $STATEDIR/.gwconfig
        if [ $CLIENT_PROTO == 'static' ] ; then
            echo "CLIENT_ADDRESS=$CLIENT_ADDRESS" >> $STATEDIR/.gwconfig
            echo "CLIENT_NETMASK=$CLIENT_NETMASK" >> $STATEDIR/.gwconfig
            echo "CLIENT_GATEWAY=$CLIENT_GATEWAY" >> $STATEDIR/.gwconfig
            echo "CLIENT_NAMESERVERS=$CLIENT_NAMESERVERS" >> $STATEDIR/.gwconfig
    fi
        snmp_user=$SNMP_USER
        snmp_password=$SNMP_PASSWORD
    fi
}

detect_qotom() {
    interfaces=$(ip link | awk '/^[0-9]*: /{print substr($2, 1, length($2)-1)}')
    ifcnt=0
    for interface in $interfaces ; do
        case $interface in
            enp?s0)   ((ifcnt++)) ;;
        esac
    done
    motherboard=$(dmidecode -s baseboard-product-name)
    [ $ifcnt -eq 4 -a "$motherboard" == 'Aptio CRB' ]
    return $?
}

select_wanif()
{
    interfaces=($(ip link show | awk '/^[0-9]*: en/{print substr($2, 1, length($2)-1)}'))
    while : ; do
        wanif=$(ip route show default | awk '{print $5}')
        local cnt=1
        for intf in "${interfaces[@]}"; do
            echo "$cnt) $intf"
            let cnt++
        done
        read -p "Which interface is connected to the Internet [$wanif]: " reply
        case $reply in
            "") ;;
            *) wanif="${interfaces[((reply-1))]}" ;;
        esac
        if [ -n "$wanif" ] ; then
            break
        fi
    done
}

select_mgmtif()
{
    interfaces=($(ip link show | awk '/^[0-9]*: en/{print substr($2, 1, length($2)-1)}') 'none')
    interfaces=($(ip link show | awk '/^[0-9]*: en/{print substr($2, 1, length($2)-1)}' | grep -v lo | grep -v "$wanif"))
    while : ; do
        local cnt=1
        for intf in "${interfaces[@]}"; do
            echo "$cnt) $intf"
            let cnt++
        done
        read -p "Which interface is to be used for a management interface [none]: " reply
        case $reply in
            "") mgmtif='';;
            *) mgmtif="${interfaces[((reply-1))]}" ;;
        esac
        if [ -n "$mgmtif" ] ; then
            break
        fi
    done
}

select_lanifs()
{
    echo "Which interface(s) are connected to the DMC?"
    interfaces=($(ip link show | awk '/^[0-9]*: en/{print substr($2, 1, length($2)-1)}' | grep -v lo | grep -v "$wanif" | grep -v "$mgmtif"))
    local selected_interfaces=""
    while : ; do
        local cnt=1
        for intf in "${interfaces[@]}"; do
            if grep -q $intf <<< $selected_interfaces ; then
                echo "$cnt) * $intf"
            else
                echo "$cnt)   $intf"
            fi
            let cnt++
        done
        echo "$cnt)   Done"
        read -p "Select interfaces toward DMC? [${selected_interfaces:-none selected}]: " reply
        case $reply in
            $cnt) break 2 ;;
            *) 
                interface="${interfaces[((reply-1))]}"
                if grep -q $interface <<< $selected_interfaces ; then
                    selected_interfaces=$(sed "s/$interface//" <<< $selected_interfaces)
                else
                    selected_interfaces="$selected_interfaces $interface"
                fi
                set -- $selected_interfaces
                selected_interfaces="$*"
                ;;
        esac
    done

    if [ -z "$selected_interfaces" ] ; then
        echo "no DMC interface selected"
        exit
    fi
    lanifs=$(sed 's/[ ][ ]*/,/g' <<< $selected_interfaces)
}

create_wanif() {
    local wanif=$1
    local mgmtif=$2
    shift
    if [ -f ${NETPLANDIR}/01-network-manager-all.yaml ] ; then
        rm ${NETPLANDIR}/01-network-manager-all.yaml
    fi
    echo "Activating WAN Interface"
    if [ $proto == 'dhcp' ] ; then
        cat < ${TOOLDIR}/templates/server/netplan/00-wan-config.tmpl | wanif="$wanif" envsubst > ${NETPLANDIR}/00-wan-config.yaml
        if [ $mgmtif != 'none' ] ; then
            cat < ${TOOLDIR}/templates/server/netplan/management-config.tmpl | mgmtif="$mgmtif" envsubst >> ${NETPLANDIR}/00-wan-config.yaml
        fi
    else
        if [ $mgmtif == 'none' ] ; then
            >&2 echo "error: refusing to apply static WAN config without a management port defined"
            exit 2
        fi
        echo "warning: connectivity may be lost and the cable may have to be switched to the $mgmtif port before proceeding with configuration"
        cat < ${TOOLDIR}/templates/server/netplan/00-wan-static-config.tmpl | wanif="$wanif" address=$address netmask=$netmask gateway=$gateway nameservers=$nameservers envsubst > ${NETPLANDIR}/00-wan-static-config.yaml
        cat < ${TOOLDIR}/templates/server/netplan/management-config.tmpl | mgmtif="$mgmtif" envsubst >> ${NETPLANDIR}/00-wan-static-config.yaml
    fi
    #
    # Don't wait for interface activation if it is unplugged
    #
    state=$(ip link show $wanif | awk "/$wanif/{print $9}")
    if [ "$state" != 'UP' ] ; then
        activate_wanif='no'
    fi

    netplan generate
    netplan apply
    if [ $activate_wanif == 'yes' ] ; then
        while [ -z "$(ip -4 addr show $wanif | awk '/inet/{print $2}')" ] ; do : ; done
    fi
}

create_dmc_lanbr() {
    local interfaces="$@"
    (
        IFS=,
        local ethernets
        for interface in $interfaces ; do
            ethernets="$ethernets $(interface=$interface envsubst < ${TOOLDIR}/templates/server/netplan/dmc_ethernet.tmpl)"
        done
        cat < ${TOOLDIR}/templates/server/netplan/30-bridge-config.tmpl | ethernets="$ethernets" interfaces="$interfaces" envsubst > ${NETPLANDIR}/30-bridge-config.yaml
    )
    netplan generate
    netplan apply
}

add_tunnel_to_lanbr() {
    local tunnel=$1
    shift
    if ! grep -q "interfaces:[ ]*\[.*${tunnel}.*]"  ${NETPLANDIR}/30-bridge-config.yaml ; then
        cat ${NETPLANDIR}/30-bridge-config.yaml | yq e ".network.bridges.lanbr0.interfaces += \"${tunnel}\"" - > $$.yaml
        mv $$.yaml ${NETPLANDIR}/30-bridge-config.yaml
    fi
}

del_tunnel_from_lanbr() {
    local tunnel=$1
    shift
    if grep -q "interfaces:[ ]*\[.*${tunnel}.*]"  ${NETPLANDIR}/30-bridge-config.yaml ; then
        # yq hasn't implemented '-=' support yet
        interfaces=$(cat ${NETPLANDIR}/30-bridge-config.yaml | yq e ".network.bridges.lanbr0.interfaces" - | sed -r "s/ ?\b${tunnel}\b,?//;s/,,/,/;s/\[ /\[/;s/,]/]/")
        sed -i.bak "s/interfaces:.*$/interfaces: ${interfaces}/" ${NETPLANDIR}/30-bridge-config.yaml
        rm ${NETPLANDIR}/30-bridge-config.yaml.bak
    fi
}

get_current_lanbr_slaves() {
    ip link show master lanbr0 | awk '/^[0-9]*: (en|gre)/{print substr($2, 1, length($2)-1)}' | sed 's/@NONE//'
}

get_next_gretap_device() {
    slaves=`get_current_lanbr_slaves`
    # start gretap devices at 1 (0 can't be used)
    cnt=1
    for (( ; ; cnt++ ))
    do
        tunnel=gretap${cnt}
        if grep -q $tunnel <<< $slaves ; then
            continue
        fi
        echo $tunnel
        break
    done
}

create_tunnel() {
    local name=$1
    shift
    local clientip=$1
    shift
    local serverip=$1
    shift

    if [ ! -f ${NETPLANDIR}/20-tunnel-${name}.yaml ] ; then
        local tunnel=`get_next_gretap_device`
        cat < ${TOOLDIR}/templates/server/netplan/20-tunnel-remotegw-n.tmpl | tunnel="$tunnel" clientip="$clientip" serverip="$serverip" envsubst > ${NETPLANDIR}/20-tunnel-${name}.yaml
        add_tunnel_to_lanbr $tunnel
        netplan generate
        netplan apply
    fi
}

destroy_tunnel() {
    local name=$1
    shift
    if [ -f ${NETPLANDIR}/20-tunnel-${name}.yaml ] ; then
        tunnel=$(cat ${NETPLANDIR}/20-tunnel-${name}.yaml | yq e ".network.tunnels" - | head -1 | sed 's/:$//')
        del_tunnel_from_lanbr $tunnel
        rm ${NETPLANDIR}/20-tunnel-${name}.yaml
        netplan generate
        netplan apply
    fi
}

restore_networking_default() {
    rm ${NETPLANDIR}/*.yaml
    cat < ${TOOLDIR}/templates/server/netplan/01-network-manager-all.tmpl > ${NETPLANDIR}/01-network-manager-all.yaml
    netplan generate
    netplan apply
}

get_server_ip() {
    echo $(ipcalc -nb ${VPNNET} | awk '/HostMin:/{print $2}')
}

get_client_ip() {
    addr_pool=()
    reserved_ips=()
    minhost=$(ipcalc -nb ${VPNNET} | awk '/HostMin:/{print $2}')
    maxhost=$(ipcalc -nb ${VPNNET} | awk '/HostMax:/{print $2}')
    lower=$(ip2dec $minhost)
    upper=$(ip2dec $maxhost)

    for ((i=lower;i<=upper;i++)); do
        addr_pool+=($i)
    done

    reserved_ips+=($lower)

    for client in ${CCDDIR}/* ; do
        if [ -e $client ] ; then
            clientip=$(awk '/^ifconfig-push/{print $2}' $client)
            reserved_ips+=($(ip2dec $clientip))
        fi
    done

    for ip in ${addr_pool[@]}; do
        for reserved in ${reserved_ips[@]}; do
            if [[ $ip -eq $reserved ]] ; then
                continue 2
            fi
        done
        dec2ip $ip
        break
    done
}

save_server_config() {
    local dest=$1
    shift
    case "$dest" in
        *.tar|*.tar.gz|*.tar.bz2|*.tar.xz) tarfile="$dest" ;;
        *)
            if nc -zw 5 "$dest" 22 ; then
                tarfile="state-$(date --iso-8601=minutes | tr ':' '-').tar.gz"
                host="$dest"
            else
                tarfile="$dest.tar.gz"
            fi
            ;;
    esac
    rm -rf $SVRSTATEDIR
    mkdir -p $SVRSTATEDIR
    cp -a $CFGDIR $SVRSTATEDIR
    cp -a $NETPLANDIR $SVRSTATEDIR
    tar cp -C $TOOLDIR -zf "$tarfile" state
    if [ -n "$host" ] ; then
        echo "Please enter the password for \"dali\" on the standby host"
        scp $tarfile dali@$host:
        echo "state archive \"$tarfile\" created and copied to the standby host dali@$host"
    else
        echo "state archive \"$tarfile\" created, please copy it to the standby host"
    fi
    echo "use the following command to import it to the standby host: "
    echo "        sudo ./dmc-access-mgr -r ~/$tarfile"
    echo
}

restore_server_config() {
    local tarfile=$1
    shift
    mkdir -p $SVRSTATEDIR
    rm -rf $SVRSTATEDIR/netplan
    rm -rf $SVRSTATEDIR/openvpn
    cp ${SERVERDIR}/server.conf $SVRSTATEDIR/server.conf
    if [ -f "$tarfile" ] ; then
        tar xp -C $TOOLDIR -f $tarfile
        rm -rf $CFGDIR.bak
        rm -rf $NETPLANDIR.bak
        mv $CFGDIR $CFGDIR.bak
        mv $NETPLANDIR $NETPLANDIR.bak
        cp -a $SVRSTATEDIR/openvpn $CFGDIR
        cp -a $SVRSTATEDIR/netplan $NETPLANDIR
        cp $SVRSTATEDIR/server.conf ${SERVERDIR}/server.conf
        if [ -d $CFGDIR -a -d $NETPLANDIR ] ; then
            netplan generate
            netplan apply
            # Restart the OpenVPN service
            systemctl restart openvpn-server@server.service
        fi
    fi
}

recover_server() {
    if [ -d $SVRSTATEDIR -a -f $STATEDIR/.svrconfig ] ; then
        load_config $STATEDIR/.svrconfig
        rm -rf $CFGDIR
        rm -rf $NETPLANDIR
        cp -a $SVRSTATEDIR/openvpn $CFGDIR
        cp -a $SVRSTATEDIR/netplan $NETPLANDIR
        if [ -d $CFGDIR -a -d $NETPLANDIR ] ; then
            netplan generate
            netplan apply
            # Restart the OpenVPN service
            systemctl restart openvpn-server@server.service
        fi
    else
        >&2 echo "error: no backup found: extract backup archive in current directoryi $TOOLDIR"
        return 2
    fi
}

setup_server_snmpd () {
    local user="$1"
    local password="$2"
    shift 2

    systemctl stop snmpd
    sed -i.bak 's/^sysLocation.*$/sysLocation Dali Management VPN Concentrator/;s/^sysContact.*$/sysContact Dali <support@daliwireless.com>/;s/^agentaddress.*$/agentaddress udp:161,udp6:[::1]:161/' /etc/snmp/snmpd.conf
    net-snmp-create-v3-user -ro -A "$password" -a MD5 -X "$password" -x DES "$user"
    systemctl start snmpd
}

#
# Prepares system for confiuration, downloads
# needed packages and configures the management
# interface. The WAN interface is left as a DHCP
# controlled interface.
#
# In this state configuration can continue without
# need for an internet connection.
#
stage_server() {
    if [ ! -e ${STATEDIR}/.staging-done ] ; then
        set -e
        # Install a firewall in the rare case where one is not already available
        if ! systemctl is-active --quiet firewalld.service && ! hash iptables 2>/dev/null; then
            if [[ "$os" == "centos" || "$os" == "fedora" ]]; then
                firewall="firewalld"
                # We do not want to silently enable firewalld, so we give a subtle warning
                # If the user continues, firewalld will be installed and enabled during setup
                echo "firewalld, which is required to manage routing tables, will also be installed."
            elif [[ "$os" == "debian" || "$os" == "ubuntu" ]]; then
                # iptables is way less invasive than firewalld so no warning is given
                firewall="iptables"
            fi
        fi
        # If running inside a container, disable LimitNPROC to prevent conflicts
        if systemd-detect-virt -cq; then
            mkdir -p /etc/systemd/system/openvpn-server@server.service.d/
            echo "[Service]
    LimitNPROC=infinity" > /etc/systemd/system/openvpn-server@server.service.d/disable-limitnproc.conf
        fi
        if [[ "$os" = "debian" || "$os" = "ubuntu" ]]; then
            apt-get update
            apt-get install -y curl ipcalc openvpn openssl ca-certificates snmpd snmp libsnmp-dev $firewall
            snap install yq
        elif [[ "$os" = "centos" ]]; then
            yum install -y epel-release
            yum install -y openvpn openssl ca-certificates tar $firewall
            #
            # These are only needed if a non default port is selected and SELinux
            # is enabled on CentOS, but in the case configuration is deferred to a
            # time when no internet is available, install them now.
            #
            if ! hash semanage 2>/dev/null; then
                if [[ "$os_version" -eq 7 ]]; then
                    # Centos 7
                    yum install -y policycoreutils-python
                else
                    # CentOS 8 or Fedora
                    dnf install -y policycoreutils-python-utils
                fi
            fi
        else
            # Else, OS must be Fedora
            dnf install -y openvpn openssl ca-certificates tar $firewall
        fi
        # If firewalld was just installed, enable it
        if [[ "$firewall" == "firewalld" ]]; then
            systemctl enable --now firewalld.service
        fi

        if [ ! -x ${SERVERDIR}/easy-rsa/easyrsa ] ; then
            # Get easy-rsa
            easy_rsa_url='https://github.com/OpenVPN/easy-rsa/releases/download/v3.0.8/EasyRSA-3.0.8.tgz'
            mkdir -p ${SERVERDIR}/easy-rsa/
            { wget -qO- "$easy_rsa_url" 2>/dev/null || curl -sL "$easy_rsa_url" ; } | tar xz -C ${SERVERDIR}/easy-rsa/ --strip-components 1
            chown -R root:root ${SERVERDIR}/easy-rsa/
        fi
        set +e
        touch ${STATEDIR}/.staging-done
    fi
}

new_client () {
    [ -f $STATEDIR/.gwconfig ] && . $STATEDIR/.gwconfig

    local serverip=$(get_server_ip)
    local clientip=$(get_client_ip)
    local netmask=$(ipcalc -nb ${VPNNET} | awk '/Netmask:/{print $2}')

    create_tunnel $client $clientip $serverip
    mkdir -p ${GWYSTATEDIR}/$client/etc
    # Generate netplan config for gateway
    mkdir -p ${GWYSTATEDIR}/$client/etc/netplan
    if [ $CLIENT_PROTO == 'static' ] ; then
        (
            export address=$CLIENT_ADDRESS
            export netmask=$CLIENT_NETMASK
            export gateway=$CLIENT_GATEWAY
            export nameservers=$CLIENT_NAMESERVERS
            cat ${TOOLDIR}/templates/client/netplan/00-static-remote-gateway.tmpl | envsubst
        ) > ${GWYSTATEDIR}/$client/etc/netplan/00-static-remote-gateway.yaml
    else
        cp ${TOOLDIR}/templates/client/netplan/00-remote-gateway.tmpl ${GWYSTATEDIR}/$client/etc/netplan/00-remote-gateway.yaml
    fi
    for template in ${TOOLDIR}/templates/client/netplan/*.tmpl ; do
        case "$template" in
            00-*.tmpl) ;;
            *.tmpl)
                if [ -e $template ] ; then
                    config=$(basename -s .tmpl $template).yaml
                    (
                        export CLIENTIP=$clientip
                        export SERVERIP=$serverip
                        cat $template | envsubst
                    ) > ${GWYSTATEDIR}/$client/etc/netplan/$config
                fi
                ;;
        esac
    done

    # Generates the custom client.ovpn
    {
    cat ${SERVERDIR}/client-common.txt
    echo "<ca>"
    cat ${SERVERDIR}/easy-rsa/pki/ca.crt
    echo "</ca>"
    echo "<cert>"
    sed -ne '/BEGIN CERTIFICATE/,$ p' ${SERVERDIR}/easy-rsa/pki/issued/"$client".crt
    echo "</cert>"
    echo "<key>"
    cat ${SERVERDIR}/easy-rsa/pki/private/"$client".key
    echo "</key>"
    echo "<tls-crypt>"
    sed -ne '/BEGIN OpenVPN Static key/,$ p' ${SERVERDIR}/tc.key
    echo "</tls-crypt>"
    } > ${CLIENTDIR}/"$client".ovpn
    echo "ifconfig-push ${clientip} ${netmask}" > ${CCDDIR}/"$client"

    mkdir -p ${GWYSTATEDIR}/$client/etc/openvpn
    cp ${CLIENTDIR}/"$client".ovpn ${GWYSTATEDIR}/$client/etc/openvpn/"$client".conf
    (
        echo '#!/bin/bash'
        echo "SNMP_USER=\"$snmp_user\""
        echo "SNMP_PASSWORD=\"$snmp_password\""
        cat ${TOOLDIR}/templates/client/selfextract_header
        tar cz -C ${GWYSTATEDIR}/$client .
    ) > ${GWYSTATEDIR}/install_$client.shar

    if [ -n "$SUDO_UID" ] ; then
        chown $SUDO_UID:$SUDO_GID ${GWYSTATEDIR}/$client
        chown $SUDO_UID:$SUDO_GID ${GWYSTATEDIR}/install_$client.shar
    fi
    chmod a+x ${GWYSTATEDIR}/install_${client}.shar

    echo "The install script for the remote gateway \"${client}\" is at:"
    echo ""
    echo "  ${GWYSTATEDIR}/install_${client}.shar"
    echo ""
    echo "Copy this file to the gateway and install it by running the command:"
    echo ""
    echo "    chmod a+x install_${client}.shar"
    echo "    sudo ./install_${client}.shar"
    echo ""
}


# MAIN starts here
# Process options

while getopts hC:c:DRr:s:x c ; do
    case $c in
        h) usage ; exit 0 ;;
        C) create_config "$OPTARG" ; exit 0 ;;
        c) load_config "$OPTARG" ;;
        D) isroot ; stage_server ; exit 0 ;;
        R) opt_R='yes' ; isroot ; recover_server ; exit $? ;;
        r) opt_r="$OPTARG" ; isroot ; restore_server_config $opt_r ; exit $? ;;
        s) opt_s="$OPTARG" ; isroot ; save_server_config $opt_s ; exit $? ;;
        x) set -x ;;
        \?) usage ; >&2 echo "unknown option: $c" ; exit 1 ;;
    esac
done

isroot

if [[ ! -e ${SERVERDIR}/server.conf ]]; then
    clear
    echo 'Welcome to this Dali DMC Access Server installer!'
    echo "The network interfaces will be reconfigured first to use netplan and networkd"
    if [ -z "$wanif" -o -z "$mgmtif" -o -z "$lanifs" ] ; then
        if detect_qotom ; then
            echo "This appears to be a Qotom network appliance"
            echo "    interface 1 should be connected to the Internet/Modem"
            echo "    interface 2 is available for connection to a management machine"
            echo "    interfaces 3 and 4 should be connected to the DMC"
            wanif='enp1s0'
            mgmtif="enp2s0"
            lanifs="enp3s0,enp4s0"
        else
            [ -z "$wanif" ] && select_wanif
            [ -z "$mgmtif" ] && select_mgmtif
            [ -z "$lanifs" ] && select_lanifs
        fi
    fi
    if [ -z "$proto" ] ; then
        ifproto_get proto
        echo

        if [ $proto == 'static' ] ;then
            staticifinfo_get
        fi
    fi
    echo "Using WAN interface $wanif"
    echo "Using DMC interface(s) $lanifs"
    create_wanif $wanif $mgmtif
    if [ -z "$address" ] ; then
        # If system has a single IPv4, it is selected automatically. Else, ask the user
        if [[ $(ip -4 addr | grep inet | grep -vEc '127(\.[0-9]{1,3}){3}') -eq 1 ]]; then
            address=$(ip -4 addr | grep inet | grep -vE '127(\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}')
        else
            number_of_ip=$(ip -4 addr | grep inet | grep -vEc '127(\.[0-9]{1,3}){3}')
            echo
            if [ $number_of_ip -eq 0 ] ; then
                >&2 echo "warning: no interface is connected, manually enter the IP address that will be assigned to $wanif"
                while : ; do
                    address=$(ipv4address_get "What is the IP address of WAN port $wanif?")
                    if [ -n "$address" ] ; then
                        break
                    fi
                done
            else
                echo "Which IPv4 address should be used?"
                ip -4 addr | grep inet | grep -vE '127(\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}' | nl -s ') '
                read -p "IPv4 address [1]: " ip_number
                until [[ -z "$ip_number" || "$ip_number" =~ ^[0-9]+$ && "$ip_number" -le "$number_of_ip" ]]; do
                    echo "$ip_number: invalid selection."
                    read -p "IPv4 address [1]: " ip_number
                done
                [[ -z "$ip_number" ]] && ip_number="1"
                address=$(ip -4 addr | grep inet | grep -vE '127(\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}' | sed -n "$ip_number"p)
            fi
        fi
    fi
    if [ -z "$public_address" ] ; then
        # If $address is a private IP address, the server must be behind NAT
        if echo "$address" | grep -qE '^(10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.|192\.168)'; then
            echo
            echo "This server is behind NAT. What is the public IPv4 address or hostname?"
            if [ $number_of_ip -eq 0 ] ; then
                while : ; do
                    public_address=$(ipv4address_get "At what public IP address will this server be reachable?")
                    if [ -n "$public_address" ] ; then
                        break
                    fi
                done
            else
                # Get public IP and sanitize with grep
                get_public_address=$(grep -m 1 -oE '^[0-9]{1,3}(\.[0-9]{1,3}){3}$' <<< "$(wget -T 10 -t 1 -4qO- "http://ip1.dynupdate.no-ip.com/" || curl -m 10 -4Ls "http://ip1.dynupdate.no-ip.com/")")
                read -p "Public IPv4 address / hostname [$get_public_address]: " public_address
                # If the checkip service is unavailable and user did not provide input, ask again
                until [[ -n "$get_public_address" || -n "$public_address" ]]; do
                    echo "Invalid input."
                    read -p "Public IPv4 address / hostname: " public_address
                done
                [[ -z "$public_address" ]] && public_address="$get_public_address"
            fi
        fi
    fi

    # If system has a single IPv6, it is selected automatically
    if [[ $(ip -6 addr | grep -c 'inet6 [23]') -eq 1 ]]; then
        ip6=$(ip -6 addr | grep 'inet6 [23]' | cut -d '/' -f 1 | grep -oE '([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}')
    fi
    # If system has multiple IPv6, ask the user to select one
    if [[ $(ip -6 addr | grep -c 'inet6 [23]') -gt 1 ]]; then
        number_of_ip6=$(ip -6 addr | grep -c 'inet6 [23]')
        echo
        echo "Which IPv6 address should be used?"
        ip -6 addr | grep 'inet6 [23]' | cut -d '/' -f 1 | grep -oE '([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}' | nl -s ') '
        read -p "IPv6 address [1]: " ip6_number
        until [[ -z "$ip6_number" || "$ip6_number" =~ ^[0-9]+$ && "$ip6_number" -le "$number_of_ip6" ]]; do
            echo "$ip6_number: invalid selection."
            read -p "IPv6 address [1]: " ip6_number
        done
        [[ -z "$ip6_number" ]] && ip6_number="1"
        ip6=$(ip -6 addr | grep 'inet6 [23]' | cut -d '/' -f 1 | grep -oE '([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}' | sed -n "$ip6_number"p)
    fi
    echo
    if [ -z "$protocol" -o -z "$port" ] ; then
        vpn_protocol_get
        echo
    fi
    if [ -z "$dns" ] ; then
        vpn_gateway_dns_option_get
        echo
    fi
    if [ -z "$client" ] ; then
        client_config
        echo
    fi
    if [ -z "$snmp_user" -o -z "$snmp_password" ] ; then
        snmp_user_get
        echo
    fi
    echo "DMC Access Server installation is ready to begin."
    read -n1 -r -p "Press any key to continue..."
    create_dmc_lanbr $lanifs

    stage_server

    VPNSERVER=$(ipcalc -nb ${VPNNET} | awk '/^Address:/{printf "%s ", $2}; /^Netmask:/{print $2}')

    cd ${SERVERDIR}/easy-rsa/
    # Create the PKI, set up the CA and the server and client certificates
    ./easyrsa init-pki
    ./easyrsa --batch build-ca nopass
    EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-server-full server nopass
    EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-client-full "$client" nopass
    EASYRSA_CRL_DAYS=3650 ./easyrsa gen-crl
    # Move the stuff we need
    cp pki/ca.crt pki/private/ca.key pki/issued/server.crt pki/private/server.key pki/crl.pem ${SERVERDIR}
    # CRL is read with each client connection, while OpenVPN is dropped to nobody
    chown nobody:"$group_name" ${SERVERDIR}/crl.pem
    # Without +x in the directory, OpenVPN can not run a stat() on the CRL file
    chmod o+x ${SERVERDIR}/
    # Generate key for tls-crypt
    openvpn --genkey --secret ${SERVERDIR}/tc.key
    # Create the DH parameters file using the predefined ffdhe2048 group
    echo '-----BEGIN DH PARAMETERS-----
MIIBCAKCAQEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz
+8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a
87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7
YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi
7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaD
ssbzSibBsu/6iGtCOGEoXJf//////////wIBAg==
-----END DH PARAMETERS-----' > ${SERVERDIR}/dh.pem
    # Generate server.conf
    echo "local $address
port $port
proto $protocol
dev tun
ca ca.crt
cert server.crt
key server.key
dh dh.pem
auth SHA512
tls-crypt tc.key
topology subnet
server ${VPNSERVER}" > ${SERVERDIR}/server.conf
    # IPv6
    if [[ -z "$ip6" ]]; then
        echo 'push "redirect-gateway def1 bypass-dhcp"' >> ${SERVERDIR}/server.conf
    else
        echo 'server-ipv6 fddd:1194:1194:1194::/64' >> ${SERVERDIR}/server.conf
        echo 'push "redirect-gateway def1 ipv6 bypass-dhcp"' >> ${SERVERDIR}/server.conf
    fi
    echo "client-config-dir ${CCDDIR}" >> ${SERVERDIR}/server.conf
    mkdir -p ${CCDDIR}
    # DNS
    case "$dns" in
        1|"")
            # Locate the proper resolv.conf
            # Needed for systems running systemd-resolved
            if grep -q '^nameserver 127.0.0.53' "/etc/resolv.conf"; then
                resolv_conf="/run/systemd/resolve/resolv.conf"
            else
                resolv_conf="/etc/resolv.conf"
            fi
            # Obtain the resolvers from resolv.conf and use them for OpenVPN
            grep -v '^#\|^;' "$resolv_conf" | grep '^nameserver' | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}' | while read line; do
                echo "push \"dhcp-option DNS $line\"" >> ${SERVERDIR}/server.conf
            done
        ;;
        2)
            echo 'push "dhcp-option DNS 8.8.8.8"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 8.8.4.4"' >> ${SERVERDIR}/server.conf
        ;;
        3)
            echo 'push "dhcp-option DNS 1.1.1.1"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 1.0.0.1"' >> ${SERVERDIR}/server.conf
        ;;
        4)
            echo 'push "dhcp-option DNS 208.67.222.222"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 208.67.220.220"' >> ${SERVERDIR}/server.conf
        ;;
        5)
            echo 'push "dhcp-option DNS 9.9.9.9"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 149.112.112.112"' >> ${SERVERDIR}/server.conf
        ;;
        6)
            echo 'push "dhcp-option DNS 94.140.14.14"' >> ${SERVERDIR}/server.conf
            echo 'push "dhcp-option DNS 94.140.15.15"' >> ${SERVERDIR}/server.conf
        ;;
    esac
    echo "keepalive 10 120
cipher AES-256-CBC
user nobody
group $group_name
log /var/log/openvpn/openvpn.log
persist-key
persist-tun
verb 3
compress lz4-v2
push \"compress lz4-v2\"
crl-verify crl.pem" >> ${SERVERDIR}/server.conf
    if [[ "$protocol" = "udp" ]]; then
        echo "explicit-exit-notify" >> ${SERVERDIR}/server.conf
    fi
    # Enable net.ipv4.ip_forward for the system
    echo 'net.ipv4.ip_forward=1' > /etc/sysctl.d/30-openvpn-forward.conf
    # Enable without waiting for a reboot or service restart
    echo 1 > /proc/sys/net/ipv4/ip_forward
    if [[ -n "$ip6" ]]; then
        # Enable net.ipv6.conf.all.forwarding for the system
        echo "net.ipv6.conf.all.forwarding=1" >> /etc/sysctl.d/30-openvpn-forward.conf
        # Enable without waiting for a reboot or service restart
        echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
    fi
    if systemctl is-active --quiet firewalld.service; then
        # Using both permanent and not permanent rules to avoid a firewalld
        # reload.
        # We do not use --add-service=openvpn because that would only work with
        # the default port and protocol.
        firewall-cmd --add-port="$port"/"$protocol"
        firewall-cmd --zone=trusted --add-source=${VPNNET}
        firewall-cmd --permanent --add-port="$port"/"$protocol"
        firewall-cmd --permanent --zone=trusted --add-source=${VPNNET}
        # Set NAT for the VPN subnet
        firewall-cmd --direct --add-rule ipv4 nat POSTROUTING 0 -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to "$address"
        firewall-cmd --permanent --direct --add-rule ipv4 nat POSTROUTING 0 -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to "$address"
        if [[ -n "$ip6" ]]; then
            firewall-cmd --zone=trusted --add-source=fddd:1194:1194:1194::/64
            firewall-cmd --permanent --zone=trusted --add-source=fddd:1194:1194:1194::/64
            firewall-cmd --direct --add-rule ipv6 nat POSTROUTING 0 -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to "$ip6"
            firewall-cmd --permanent --direct --add-rule ipv6 nat POSTROUTING 0 -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to "$ip6"
        fi
    else
        # Create a service to set up persistent iptables rules
        iptables_path=$(command -v iptables)
        ip6tables_path=$(command -v ip6tables)
        # nf_tables is not available as standard in OVZ kernels. So use iptables-legacy
        # if we are in OVZ, with a nf_tables backend and iptables-legacy is available.
        if [[ $(systemd-detect-virt) == "openvz" ]] && readlink -f "$(command -v iptables)" | grep -q "nft" && hash iptables-legacy 2>/dev/null; then
            iptables_path=$(command -v iptables-legacy)
            ip6tables_path=$(command -v ip6tables-legacy)
        fi
        echo "[Unit]
Before=network.target
[Service]
Type=oneshot
ExecStart=$iptables_path -t nat -A POSTROUTING -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to $address
ExecStart=$iptables_path -I INPUT -p $protocol --dport $port -j ACCEPT
ExecStart=$iptables_path -I FORWARD -s ${VPNNET} -j ACCEPT
ExecStart=$iptables_path -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
ExecStop=$iptables_path -t nat -D POSTROUTING -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to $address
ExecStop=$iptables_path -D INPUT -p $protocol --dport $port -j ACCEPT
ExecStop=$iptables_path -D FORWARD -s ${VPNNET} -j ACCEPT
ExecStop=$iptables_path -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT" > /etc/systemd/system/openvpn-iptables.service
        if [[ -n "$ip6" ]]; then
            echo "ExecStart=$ip6tables_path -t nat -A POSTROUTING -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to $ip6
ExecStart=$ip6tables_path -I FORWARD -s fddd:1194:1194:1194::/64 -j ACCEPT
ExecStart=$ip6tables_path -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
ExecStop=$ip6tables_path -t nat -D POSTROUTING -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to $ip6
ExecStop=$ip6tables_path -D FORWARD -s fddd:1194:1194:1194::/64 -j ACCEPT
ExecStop=$ip6tables_path -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT" >> /etc/systemd/system/openvpn-iptables.service
        fi
        echo "RemainAfterExit=yes
[Install]
WantedBy=multi-user.target" >> /etc/systemd/system/openvpn-iptables.service
        systemctl enable --now openvpn-iptables.service
    fi
    # If SELinux is enabled and a custom port was selected, we need this
    if sestatus 2>/dev/null | grep "Current mode" | grep -q "enforcing" && [[ "$port" != 1194 ]]; then
        #
        # semanage is installed in the server_stage() function if required
        #
        semanage port -a -t openvpn_port_t -p "$protocol" "$port"
    fi
    # If the server is behind NAT, use the correct IP address
    [[ -n "$public_address" ]] && address="$public_address"
    # client-common.txt is created so we have a template to add further users later
    echo "client
dev tun
proto $protocol
remote $address $port
resolv-retry infinite
nobind
persist-key
persist-tun
remote-cert-tls server
auth SHA512
cipher AES-256-CBC
ignore-unknown-option block-outside-dns
block-outside-dns
comp-lzo
verb 3" > ${SERVERDIR}/client-common.txt
    # Enable and start the OpenVPN service
    systemctl enable --now openvpn-server@server.service
    if [ ! -f $STATEDIR/.snmpauth ] ; then
        # Setup SNMP monitoring
        setup_server_snmpd "$snmp_user" "$snmp_password"
        echo "snmp_user=\"$snmp_user\"" > $STATEDIR/.snmpauth
        echo "snmp_password=\"$snmp_password\"" >> $STATEDIR/.snmpauth
    fi
    # Generates the custom client.ovpn
    new_client
    if [ ! -f $STATEDIR/.svrconfig ] ; then
        write_config_file $STATEDIR/.svrconfig
    fi
    echo
    echo "Finished!"
    echo
    echo "New clients can be added by running this script again."
else
    clear
    echo "DMC Access Server is already installed."
    echo
    echo "Select an option:"
    echo "   1) Add a new remote gateway"
    echo "   2) Revoke an existing remote gateway"
    echo "   3) Remove DMC Access Server"
    echo "   4) Exit"
    read -p "Option: " option
    until [[ "$option" =~ ^[1-4]$ ]]; do
        echo "$option: invalid selection."
        read -p "Option: " option
    done
    case "$option" in
        1)
            echo
            echo "Provide a name for the gateway:"
            read -p "Name: " unsanitized_client
            client=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_client")
            while [[ -z "$client" || -e ${SERVERDIR}/easy-rsa/pki/issued/"$client".crt ]]; do
                echo "$client: invalid name."
                read -p "Name: " unsanitized_client
                client=$(sed 's/[^0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-]/_/g' <<< "$unsanitized_client")
            done
            cd ${SERVERDIR}/easy-rsa/
            EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-client-full "$client" nopass
            # Generates the custom client.ovpn
            new_client
            exit
        ;;
        2)
            # This option could be documented a bit better and maybe even be simplified
            # ...but what can I say, I want some sleep too
            number_of_clients=$(tail -n +2 ${SERVERDIR}/easy-rsa/pki/index.txt | grep -c "^V")
            if [[ "$number_of_clients" = 0 ]]; then
                echo
                echo "There are no existing gateways!"
                exit
            fi
            echo
            echo "Select the gateway to revoke:"
            tail -n +2 ${SERVERDIR}/easy-rsa/pki/index.txt | grep "^V" | cut -d '=' -f 2 | nl -s ') '
            read -p "Gateway: " client_number
            until [[ "$client_number" =~ ^[0-9]+$ && "$client_number" -le "$number_of_clients" ]]; do
                echo "$client_number: invalid selection."
                read -p "Gateway: " client_number
            done
            client=$(tail -n +2 ${SERVERDIR}/easy-rsa/pki/index.txt | grep "^V" | cut -d '=' -f 2 | sed -n "$client_number"p)
            echo
            read -p "Confirm $client revocation? [y/N]: " revoke
            until [[ "$revoke" =~ ^[yYnN]*$ ]]; do
                echo "$revoke: invalid selection."
                read -p "Confirm $client revocation? [y/N]: " revoke
            done
            if [[ "$revoke" =~ ^[yY]$ ]]; then
                cd ${SERVERDIR}/easy-rsa/
                ./easyrsa --batch revoke "$client"
                EASYRSA_CRL_DAYS=3650 ./easyrsa gen-crl
                rm -f ${SERVERDIR}/crl.pem
                cp ${SERVERDIR}/easy-rsa/pki/crl.pem ${SERVERDIR}/crl.pem
                # CRL is read with each client connection, when OpenVPN is dropped to nobody
                chown nobody:"$group_name" ${SERVERDIR}/crl.pem
                echo
                destroy_tunnel $client
                echo "$client revoked!"
            else
                echo
                echo "$client revocation aborted!"
            fi
            exit
        ;;
        3)
            echo
            read -p "Confirm DMC Access Server removal? [y/N]: " remove
            until [[ "$remove" =~ ^[yYnN]*$ ]]; do
                echo "$remove: invalid selection."
                read -p "Confirm DMC Access Server removal? [y/N]: " remove
            done
            if [[ "$remove" =~ ^[yY]$ ]]; then
                port=$(grep '^port ' ${SERVERDIR}/server.conf | cut -d " " -f 2)
                protocol=$(grep '^proto ' ${SERVERDIR}/server.conf | cut -d " " -f 2)
                if systemctl is-active --quiet firewalld.service; then
                    address=$(firewall-cmd --direct --get-rules ipv4 nat POSTROUTING | grep "\-s ${VPNNET} ""'"'!'"'"" -d ${VPNNET}" | grep -oE '[^ ]+$')
                    # Using both permanent and not permanent rules to avoid a firewalld reload.
                    firewall-cmd --remove-port="$port"/"$protocol"
                    firewall-cmd --zone=trusted --remove-source=${VPNNET}
                    firewall-cmd --permanent --remove-port="$port"/"$protocol"
                    firewall-cmd --permanent --zone=trusted --remove-source=${VPNNET}
                    firewall-cmd --direct --remove-rule ipv4 nat POSTROUTING 0 -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to "$address"
                    firewall-cmd --permanent --direct --remove-rule ipv4 nat POSTROUTING 0 -s ${VPNNET} ! -d ${VPNNET} -j SNAT --to "$address"
                    if grep -qs "server-ipv6" ${SERVERDIR}/server.conf; then
                        ip6=$(firewall-cmd --direct --get-rules ipv6 nat POSTROUTING | grep '\-s fddd:1194:1194:1194::/64 '"'"'!'"'"' -d fddd:1194:1194:1194::/64' | grep -oE '[^ ]+$')
                        firewall-cmd --zone=trusted --remove-source=fddd:1194:1194:1194::/64
                        firewall-cmd --permanent --zone=trusted --remove-source=fddd:1194:1194:1194::/64
                        firewall-cmd --direct --remove-rule ipv6 nat POSTROUTING 0 -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to "$ip6"
                        firewall-cmd --permanent --direct --remove-rule ipv6 nat POSTROUTING 0 -s fddd:1194:1194:1194::/64 ! -d fddd:1194:1194:1194::/64 -j SNAT --to "$ip6"
                    fi
                else
                    systemctl disable --now openvpn-iptables.service
                    rm -f /etc/systemd/system/openvpn-iptables.service
                fi
                if sestatus 2>/dev/null | grep "Current mode" | grep -q "enforcing" && [[ "$port" != 1194 ]]; then
                    semanage port -d -t openvpn_port_t -p "$protocol" "$port"
                fi
                systemctl disable --now openvpn-server@server.service
                rm -rf ${SERVERDIR}
                rm -f /etc/systemd/system/openvpn-server@server.service.d/disable-limitnproc.conf
                rm -f /etc/sysctl.d/30-openvpn-forward.conf
                restore_networking_default
                rm -rf /etc/openvpn/server/*
                rm -rf /etc/openvpn/gateway/*
                rm -rf /etc/openvpn/ccd/*
                rm -rf ${STATEDIR}
                #
                # Do not remove the software package. If this is a staged machine
                # it may be difficult to reinstall it. Just stop it and remove configuration
                #
                echo
                echo "DMC Access Server removed!"
            else
                echo
                echo "DMC Access Server removal aborted!"
            fi
            exit
        ;;
        4)
            exit
        ;;
    esac
fi

